/// Golden Comparison Tests - Compare AGG port output with Cairo reference
/// 
/// These tests compare the images generated by the Dart AGG port with
/// reference images generated by Cairo to validate rendering quality.
///
/// PSNR thresholds:
/// - Shapes: >30 dB (pixel-perfect required - same algorithm)
/// - Text: >14 dB (different font engines - Cairo/FreeType vs AGG/Typography)
/// - Anti-aliasing: >20 dB (different AA algorithms)

import 'dart:io';
import 'dart:math';
import 'package:image/image.dart' as img;
import 'package:test/test.dart';

/// Minimum PSNR for pixel-perfect rendering (30 dB means < 0.1% pixel error)
const double kPixelPerfectPsnr = 30.0;

/// Minimum PSNR for text rendering (different font engines produce different results)
/// Cairo uses FreeType rasterizer, AGG uses its own Typography engine
const double kTextPsnr = 14.0;

/// Minimum PSNR for anti-aliasing comparison (different AA algorithms)
const double kAntialiasingPsnr = 20.0;

void main() {
  setUpAll(() {
    Directory('test/golden').createSync(recursive: true);
    Directory('test/tmp').createSync(recursive: true);
  });

  group('Golden Comparison - Shapes (PIXEL-PERFECT required)', () {
    test('shape_heart: AGG vs Cairo - BEZIER CURVES', () {
      final result = compareImages(
        'test/tmp/shape_heart.png',
        'test/golden/shape_heart.png',
        'shape_heart',
      );
      _printResult('Heart shape (bezier curves)', result);
      expect(result.psnr, greaterThan(kPixelPerfectPsnr), 
        reason: 'Heart shape bezier curves must be pixel-perfect. Current PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });

    test('shape_spiral: AGG vs Cairo - LINE SEGMENTS', () {
      final result = compareImages(
        'test/tmp/shape_spiral.png',
        'test/golden/shape_spiral.png',
        'shape_spiral',
      );
      _printResult('Spiral shape (line segments)', result);
      expect(result.psnr, greaterThan(kPixelPerfectPsnr), 
        reason: 'Spiral must be pixel-perfect. Current PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });

    test('shape_bezier: AGG vs Cairo - BEZIER CURVES', () {
      final result = compareImages(
        'test/tmp/shape_bezier.png',
        'test/golden/shape_bezier.png',
        'shape_bezier',
      );
      _printResult('Bezier curves', result);
      expect(result.psnr, greaterThan(kPixelPerfectPsnr), 
        reason: 'Bezier curves must be pixel-perfect. AGG is drawing LINES instead of CURVES! PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });

    test('shape_star: AGG vs Cairo - POLYGON', () {
      final result = compareImages(
        'test/tmp/shape_star.png',
        'test/golden/shape_star.png',
        'shape_star',
      );
      _printResult('Star shape (polygon)', result);
      expect(result.psnr, greaterThan(kPixelPerfectPsnr), 
        reason: 'Star polygon must be pixel-perfect. Current PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });

    test('shape_concentric: AGG vs Cairo - CIRCLES', () {
      final result = compareImages(
        'test/tmp/shape_concentric.png',
        'test/golden/shape_concentric.png',
        'shape_concentric',
      );
      _printResult('Concentric circles', result);
      expect(result.psnr, greaterThan(kPixelPerfectPsnr), 
        reason: 'Concentric circles must be pixel-perfect. Current PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });

    test('shape_rounded_rects: AGG vs Cairo - ROUNDED RECTANGLES', () {
      final result = compareImages(
        'test/tmp/shape_rounded_rects.png',
        'test/golden/shape_rounded_rects.png',
        'shape_rounded_rects',
      );
      _printResult('Rounded rectangles', result);
      expect(result.psnr, greaterThan(kPixelPerfectPsnr), 
        reason: 'Rounded rectangles must be pixel-perfect. Current PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });
  });

  group('Golden Comparison - Text (font engine differences expected)', () {
    test('text_hello_world: AGG vs Cairo - BASIC TEXT', () {
      final result = compareImages(
        'test/tmp/text_hello_world.png',
        'test/golden/text_hello_world.png',
        'text_hello_world',
      );
      _printResult('Hello World text', result);
      expect(result.psnr, greaterThan(kTextPsnr), 
        reason: 'Text rendering quality too low. Current PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });

    test('text_outlined: AGG vs Cairo - OUTLINED TEXT', () {
      final result = compareImages(
        'test/tmp/text_outlined.png',
        'test/golden/text_outlined.png',
        'text_outlined',
      );
      _printResult('Outlined text', result);
      expect(result.psnr, greaterThan(kTextPsnr), 
        reason: 'Outlined text quality too low. Current PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });

    test('text_mixed_styles: AGG vs Cairo - MIXED STYLES', () {
      final result = compareImages(
        'test/tmp/text_mixed_styles.png',
        'test/golden/text_mixed_styles.png',
        'text_mixed_styles',
      );
      _printResult('Mixed styles text', result);
      expect(result.psnr, greaterThan(kTextPsnr), 
        reason: 'Mixed styles text quality too low. Current PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });
  });

  group('Golden Comparison - Anti-aliasing (algorithm differences expected)', () {
    test('aa_diagonals: AGG vs Cairo - DIAGONAL LINES', () {
      if (!File('test/tmp/aa_diagonals.png').existsSync()) {
        fail('test/tmp/aa_diagonals.png does not exist - run AGG tests first');
      }
      
      final result = compareImages(
        'test/tmp/aa_diagonals.png',
        'test/golden/aa_diagonals.png',
        'aa_diagonals',
      );
      _printResult('Diagonal lines AA', result);
      expect(result.psnr, greaterThan(kAntialiasingPsnr), 
        reason: 'Anti-aliasing quality too low. Current PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });

    test('aa_small_circles: AGG vs Cairo - SMALL CIRCLES', () {
      if (!File('test/tmp/aa_small_circles.png').existsSync()) {
        fail('test/tmp/aa_small_circles.png does not exist - run AGG tests first');
      }
      
      final result = compareImages(
        'test/tmp/aa_small_circles.png',
        'test/golden/aa_small_circles.png',
        'aa_small_circles',
      );
      _printResult('Small circles AA', result);
      expect(result.psnr, greaterThan(kPixelPerfectPsnr), 
        reason: 'Small circles must be pixel-perfect. Current PSNR: ${result.psnr.toStringAsFixed(2)} dB');
    });
  });
}

void _printResult(String name, ComparisonResult result) {
  print('$name comparison:');
  print('  PSNR: ${result.psnr.toStringAsFixed(2)} dB (higher is better, >30 is good)');
  print('  MSE: ${result.mse.toStringAsFixed(4)}');
  print('  Different pixels: ${result.differentPixels} / ${result.totalPixels} (${result.percentDifferent.toStringAsFixed(2)}%)');
}

/// Result of comparing two images
class ComparisonResult {
  final double psnr;
  final double mse;
  final int differentPixels;
  final int totalPixels;
  
  ComparisonResult({
    required this.psnr,
    required this.mse,
    required this.differentPixels,
    required this.totalPixels,
  });
  
  double get percentDifferent => totalPixels > 0 ? (differentPixels / totalPixels) * 100 : 0;
}

/// Compare two PNG images and return metrics
ComparisonResult compareImages(String path1, String path2, String name) {
  final file1 = File(path1);
  final file2 = File(path2);
  
  if (!file1.existsSync()) {
    print('Warning: $path1 does not exist');
    return ComparisonResult(
      psnr: 0,
      mse: double.infinity,
      differentPixels: -1,
      totalPixels: 0,
    );
  }
  
  if (!file2.existsSync()) {
    print('Warning: $path2 does not exist');
    return ComparisonResult(
      psnr: 0,
      mse: double.infinity,
      differentPixels: -1,
      totalPixels: 0,
    );
  }
  
  // Load and decode both PNG files
  final bytes1 = file1.readAsBytesSync();
  final bytes2 = file2.readAsBytesSync();
  
  final img1 = img.decodePng(bytes1);
  final img2 = img.decodePng(bytes2);
  
  if (img1 == null || img2 == null) {
    print('Warning: Could not decode PNG files');
    return ComparisonResult(
      psnr: 0,
      mse: double.infinity,
      differentPixels: -1,
      totalPixels: 0,
    );
  }
  
  // Resize if needed to compare
  final width = min(img1.width, img2.width);
  final height = min(img1.height, img2.height);
  final totalPixels = width * height;
  
  // Calculate MSE and count different pixels
  var sumSquaredError = 0.0;
  var differentPixels = 0;
  const threshold = 16; // Pixel difference threshold
  
  // Create diff image
  final diff = img.Image(width: width, height: height);
  
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      final c1 = img1.getPixel(x, y);
      final c2 = img2.getPixel(x, y);
      
      final dr = (c1.r.toInt() - c2.r.toInt()).abs();
      final dg = (c1.g.toInt() - c2.g.toInt()).abs();
      final db = (c1.b.toInt() - c2.b.toInt()).abs();
      
      sumSquaredError += dr * dr + dg * dg + db * db;
      
      final maxDiff = max(dr, max(dg, db));
      if (maxDiff > threshold) {
        differentPixels++;
        // Highlight differences in red
        diff.setPixelRgba(x, y, 255, 0, 0, 255);
      } else {
        // Show grayscale of original
        final gray = ((c1.r.toInt() + c1.g.toInt() + c1.b.toInt()) / 3).round().clamp(0, 255);
        diff.setPixelRgba(x, y, gray, gray, gray, 255);
      }
    }
  }
  
  final mse = sumSquaredError / (totalPixels * 3);
  final psnr = mse > 0 ? 10 * log(255 * 255 / mse) / ln10 : double.infinity;
  
  // Save diff image
  try {
    final diffPath = 'test/tmp/${name}.diff.png';
    File(diffPath).writeAsBytesSync(img.encodePng(diff));
  } catch (e) {
    print('Warning: Could not save diff image: $e');
  }
  
  return ComparisonResult(
    psnr: psnr,
    mse: mse,
    differentPixels: differentPixels,
    totalPixels: totalPixels,
  );
}
