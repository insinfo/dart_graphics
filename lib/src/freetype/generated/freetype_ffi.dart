// ignore_for_file: camel_case_types, non_constant_identifier_names, unused_element
// ignore_for_file: constant_identifier_names, public_member_api_docs
// ignore_for_file: unused_field, lines_longer_than_80_chars

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to FreeType Library for Dart.
class FreeTypeBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FreeTypeBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FreeTypeBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// @function:
  /// FT_Init_FreeType
  ///
  /// @description:
  /// Initialize a new FreeType library object.  The set of modules that are
  /// registered by this function is determined at build time.
  ///
  /// @output:
  /// alibrary ::
  /// A handle to a new library object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// In case you want to provide your own memory allocating routines, use
  /// @FT_New_Library instead, followed by a call to @FT_Add_Default_Modules
  /// (or a series of calls to @FT_Add_Module) and
  /// @FT_Set_Default_Properties.
  ///
  /// See the documentation of @FT_Library and @FT_Face for multi-threading
  /// issues.
  ///
  /// If you need reference-counting (cf. @FT_Reference_Library), use
  /// @FT_New_Library and @FT_Done_Library.
  ///
  /// If compilation option `FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES` is
  /// set, this function reads the `FREETYPE_PROPERTIES` environment
  /// variable to control driver properties.  See section @properties for
  /// more.
  int FT_Init_FreeType(
    ffi.Pointer<FT_Library> alibrary,
  ) {
    return _FT_Init_FreeType(
      alibrary,
    );
  }

  late final _FT_Init_FreeTypePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(ffi.Pointer<FT_Library>)>>(
          'FT_Init_FreeType');
  late final _FT_Init_FreeType =
      _FT_Init_FreeTypePtr.asFunction<int Function(ffi.Pointer<FT_Library>)>();

  /// @function:
  /// FT_Done_FreeType
  ///
  /// @description:
  /// Destroy a given FreeType library object and all of its children,
  /// including resources, drivers, faces, sizes, etc.
  ///
  /// @input:
  /// library ::
  /// A handle to the target library object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  int FT_Done_FreeType(
    FT_Library library$,
  ) {
    return _FT_Done_FreeType(
      library$,
    );
  }

  late final _FT_Done_FreeTypePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Library)>>(
          'FT_Done_FreeType');
  late final _FT_Done_FreeType =
      _FT_Done_FreeTypePtr.asFunction<int Function(FT_Library)>();

  /// @function:
  /// FT_New_Face
  ///
  /// @description:
  /// Call @FT_Open_Face to open a font by its pathname.
  ///
  /// @inout:
  /// library ::
  /// A handle to the library resource.
  ///
  /// @input:
  /// pathname ::
  /// A path to the font file.
  ///
  /// face_index ::
  /// See @FT_Open_Face for a detailed description of this parameter.
  ///
  /// @output:
  /// aface ::
  /// A handle to a new face object.  If `face_index` is greater than or
  /// equal to zero, it must be non-`NULL`.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// The `pathname` string should be recognizable as such by a standard
  /// `fopen` call on your system; in particular, this means that `pathname`
  /// must not contain null bytes.  If that is not sufficient to address all
  /// file name possibilities (for example, to handle wide character file
  /// names on Windows in UTF-16 encoding) you might use @FT_Open_Face to
  /// pass a memory array or a stream object instead.
  ///
  /// Use @FT_Done_Face to destroy the created @FT_Face object (along with
  /// its slot and sizes).
  int FT_New_Face(
    FT_Library library$,
    ffi.Pointer<ffi.Char> filepathname,
    int face_index,
    ffi.Pointer<FT_Face> aface,
  ) {
    return _FT_New_Face(
      library$,
      filepathname,
      face_index,
      aface,
    );
  }

  late final _FT_New_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<ffi.Char>, FT_Long,
              ffi.Pointer<FT_Face>)>>('FT_New_Face');
  late final _FT_New_Face = _FT_New_FacePtr.asFunction<
      int Function(
          FT_Library, ffi.Pointer<ffi.Char>, int, ffi.Pointer<FT_Face>)>();

  /// @function:
  /// FT_New_Memory_Face
  ///
  /// @description:
  /// Call @FT_Open_Face to open a font that has been loaded into memory.
  ///
  /// @inout:
  /// library ::
  /// A handle to the library resource.
  ///
  /// @input:
  /// file_base ::
  /// A pointer to the beginning of the font data.
  ///
  /// file_size ::
  /// The size of the memory chunk used by the font data.
  ///
  /// face_index ::
  /// See @FT_Open_Face for a detailed description of this parameter.
  ///
  /// @output:
  /// aface ::
  /// A handle to a new face object.  If `face_index` is greater than or
  /// equal to zero, it must be non-`NULL`.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// You must not deallocate the memory before calling @FT_Done_Face.
  int FT_New_Memory_Face(
    FT_Library library$,
    ffi.Pointer<ffi.UnsignedChar> file_base,
    int file_size,
    int face_index,
    ffi.Pointer<FT_Face> aface,
  ) {
    return _FT_New_Memory_Face(
      library$,
      file_base,
      file_size,
      face_index,
      aface,
    );
  }

  late final _FT_New_Memory_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<ffi.UnsignedChar>, FT_Long,
              FT_Long, ffi.Pointer<FT_Face>)>>('FT_New_Memory_Face');
  late final _FT_New_Memory_Face = _FT_New_Memory_FacePtr.asFunction<
      int Function(FT_Library, ffi.Pointer<ffi.UnsignedChar>, int, int,
          ffi.Pointer<FT_Face>)>();

  /// @function:
  /// FT_Reference_Face
  ///
  /// @description:
  /// A counter gets initialized to~1 at the time an @FT_Face structure is
  /// created.  This function increments the counter.  @FT_Done_Face then
  /// only destroys a face if the counter is~1, otherwise it simply
  /// decrements the counter.
  ///
  /// This function helps in managing life-cycles of structures that
  /// reference @FT_Face objects.
  ///
  /// @input:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @since:
  /// 2.4.2
  int FT_Reference_Face(
    FT_Face face,
  ) {
    return _FT_Reference_Face(
      face,
    );
  }

  late final _FT_Reference_FacePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face)>>(
          'FT_Reference_Face');
  late final _FT_Reference_Face =
      _FT_Reference_FacePtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Done_Face
  ///
  /// @description:
  /// Discard a given face object, as well as all of its child slots and
  /// sizes.
  ///
  /// @input:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// See the discussion of reference counters in the description of
  /// @FT_Reference_Face.
  int FT_Done_Face(
    FT_Face face,
  ) {
    return _FT_Done_Face(
      face,
    );
  }

  late final _FT_Done_FacePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face)>>('FT_Done_Face');
  late final _FT_Done_Face =
      _FT_Done_FacePtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Select_Size
  ///
  /// @description:
  /// Select a bitmap strike.  To be more precise, this function sets the
  /// scaling factors of the active @FT_Size object in a face so that
  /// bitmaps from this particular strike are taken by @FT_Load_Glyph and
  /// friends.
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @input:
  /// strike_index ::
  /// The index of the bitmap strike in the `available_sizes` field of
  /// @FT_FaceRec structure.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// For bitmaps embedded in outline fonts it is common that only a subset
  /// of the available glyphs at a given ppem value is available.  FreeType
  /// silently uses outlines if there is no bitmap for a given glyph index.
  ///
  /// For GX and OpenType variation fonts, a bitmap strike makes sense only
  /// if the default instance is active (that is, no glyph variation takes
  /// place); otherwise, FreeType simply ignores bitmap strikes.  The same
  /// is true for all named instances that are different from the default
  /// instance.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Select_Size(
    FT_Face face,
    int strike_index,
  ) {
    return _FT_Select_Size(
      face,
      strike_index,
    );
  }

  late final _FT_Select_SizePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_Int)>>(
          'FT_Select_Size');
  late final _FT_Select_Size =
      _FT_Select_SizePtr.asFunction<int Function(FT_Face, int)>();

  /// @function:
  /// FT_Request_Size
  ///
  /// @description:
  /// Resize the scale of the active @FT_Size object in a face.
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @input:
  /// req ::
  /// A pointer to a @FT_Size_RequestRec.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Although drivers may select the bitmap strike matching the request,
  /// you should not rely on this if you intend to select a particular
  /// bitmap strike.  Use @FT_Select_Size instead in that case.
  ///
  /// The relation between the requested size and the resulting glyph size
  /// is dependent entirely on how the size is defined in the source face.
  /// The font designer chooses the final size of each glyph relative to
  /// this size.  For more information refer to
  /// 'https://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'.
  ///
  /// Contrary to @FT_Set_Char_Size, this function doesn't have special code
  /// to normalize zero-valued widths, heights, or resolutions, which are
  /// treated as @FT_LOAD_NO_SCALE.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Request_Size(
    FT_Face face,
    ffi.Pointer<FT_Size_RequestRec_> req,
  ) {
    return _FT_Request_Size(
      face,
      req,
    );
  }

  late final _FT_Request_SizePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(
              FT_Face, ffi.Pointer<FT_Size_RequestRec_>)>>('FT_Request_Size');
  late final _FT_Request_Size = _FT_Request_SizePtr.asFunction<
      int Function(FT_Face, ffi.Pointer<FT_Size_RequestRec_>)>();

  /// @function:
  /// FT_Set_Char_Size
  ///
  /// @description:
  /// Call @FT_Request_Size to request the nominal size (in points).
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @input:
  /// char_width ::
  /// The nominal width, in 26.6 fractional points.
  ///
  /// char_height ::
  /// The nominal height, in 26.6 fractional points.
  ///
  /// horz_resolution ::
  /// The horizontal resolution in dpi.
  ///
  /// vert_resolution ::
  /// The vertical resolution in dpi.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// While this function allows fractional points as input values, the
  /// resulting ppem value for the given resolution is always rounded to the
  /// nearest integer.
  ///
  /// If either the character width or height is zero, it is set equal to
  /// the other value.
  ///
  /// If either the horizontal or vertical resolution is zero, it is set
  /// equal to the other value.
  ///
  /// A character width or height smaller than 1pt is set to 1pt; if both
  /// resolution values are zero, they are set to 72dpi.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Set_Char_Size(
    FT_Face face,
    int char_width,
    int char_height,
    int horz_resolution,
    int vert_resolution,
  ) {
    return _FT_Set_Char_Size(
      face,
      char_width,
      char_height,
      horz_resolution,
      vert_resolution,
    );
  }

  late final _FT_Set_Char_SizePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_F26Dot6, FT_F26Dot6, FT_UInt,
              FT_UInt)>>('FT_Set_Char_Size');
  late final _FT_Set_Char_Size = _FT_Set_Char_SizePtr.asFunction<
      int Function(FT_Face, int, int, int, int)>();

  /// @function:
  /// FT_Set_Pixel_Sizes
  ///
  /// @description:
  /// Call @FT_Request_Size to request the nominal size (in pixels).
  ///
  /// @inout:
  /// face ::
  /// A handle to the target face object.
  ///
  /// @input:
  /// pixel_width ::
  /// The nominal width, in pixels.
  ///
  /// pixel_height ::
  /// The nominal height, in pixels.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// You should not rely on the resulting glyphs matching or being
  /// constrained to this pixel size.  Refer to @FT_Request_Size to
  /// understand how requested sizes relate to actual sizes.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Set_Pixel_Sizes(
    FT_Face face,
    int pixel_width,
    int pixel_height,
  ) {
    return _FT_Set_Pixel_Sizes(
      face,
      pixel_width,
      pixel_height,
    );
  }

  late final _FT_Set_Pixel_SizesPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_UInt, FT_UInt)>>(
          'FT_Set_Pixel_Sizes');
  late final _FT_Set_Pixel_Sizes =
      _FT_Set_Pixel_SizesPtr.asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Load_Glyph
  ///
  /// @description:
  /// Load a glyph into the glyph slot of a face object.
  ///
  /// @inout:
  /// face ::
  /// A handle to the target face object where the glyph is loaded.
  ///
  /// @input:
  /// glyph_index ::
  /// The index of the glyph in the font file.  For CID-keyed fonts
  /// (either in PS or in CFF format) this argument specifies the CID
  /// value.
  ///
  /// load_flags ::
  /// A flag indicating what to load for this glyph.  The @FT_LOAD_XXX
  /// flags can be used to control the glyph loading process (e.g.,
  /// whether the outline should be scaled, whether to load bitmaps or
  /// not, whether to hint the outline, etc).
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// For proper scaling and hinting, the active @FT_Size object owned by
  /// the face has to be meaningfully initialized by calling
  /// @FT_Set_Char_Size before this function, for example.  The loaded
  /// glyph may be transformed.  See @FT_Set_Transform for the details.
  ///
  /// For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument` is returned
  /// for invalid CID values (that is, for CID values that don't have a
  /// corresponding glyph in the font).  See the discussion of the
  /// @FT_FACE_FLAG_CID_KEYED flag for more details.
  ///
  /// If you receive `FT_Err_Glyph_Too_Big`, try getting the glyph outline
  /// at EM size, then scale it manually and fill it as a graphics
  /// operation.
  int FT_Load_Glyph(
    FT_Face face,
    int glyph_index,
    int load_flags,
  ) {
    return _FT_Load_Glyph(
      face,
      glyph_index,
      load_flags,
    );
  }

  late final _FT_Load_GlyphPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_UInt, ffi.Int)>>(
          'FT_Load_Glyph');
  late final _FT_Load_Glyph =
      _FT_Load_GlyphPtr.asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Load_Char
  ///
  /// @description:
  /// Load a glyph into the glyph slot of a face object, accessed by its
  /// character code.
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object where the glyph is loaded.
  ///
  /// @input:
  /// char_code ::
  /// The glyph's character code, according to the current charmap used in
  /// the face.
  ///
  /// load_flags ::
  /// A flag indicating what to load for this glyph.  The @FT_LOAD_XXX
  /// constants can be used to control the glyph loading process (e.g.,
  /// whether the outline should be scaled, whether to load bitmaps or
  /// not, whether to hint the outline, etc).
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// This function simply calls @FT_Get_Char_Index and @FT_Load_Glyph.
  ///
  /// Many fonts contain glyphs that can't be loaded by this function since
  /// its glyph indices are not listed in any of the font's charmaps.
  ///
  /// If no active cmap is set up (i.e., `face->charmap` is zero), the call
  /// to @FT_Get_Char_Index is omitted, and the function behaves identically
  /// to @FT_Load_Glyph.
  int FT_Load_Char(
    FT_Face face,
    int char_code,
    int load_flags,
  ) {
    return _FT_Load_Char(
      face,
      char_code,
      load_flags,
    );
  }

  late final _FT_Load_CharPtr = _lookup<
          ffi.NativeFunction<FT_Error Function(FT_Face, FT_ULong, ffi.Int)>>(
      'FT_Load_Char');
  late final _FT_Load_Char =
      _FT_Load_CharPtr.asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Render_Glyph
  ///
  /// @description:
  /// Convert a given glyph image to a bitmap.  It does so by inspecting the
  /// glyph image format, finding the relevant renderer, and invoking it.
  ///
  /// @inout:
  /// slot ::
  /// A handle to the glyph slot containing the image to convert.
  ///
  /// @input:
  /// render_mode ::
  /// The render mode used to render the glyph image into a bitmap.  See
  /// @FT_Render_Mode for a list of possible values.
  ///
  /// If @FT_RENDER_MODE_NORMAL is used, a previous call of @FT_Load_Glyph
  /// with flag @FT_LOAD_COLOR makes `FT_Render_Glyph` provide a default
  /// blending of colored glyph layers associated with the current glyph
  /// slot (provided the font contains such layers) instead of rendering
  /// the glyph slot's outline.  This is an experimental feature; see
  /// @FT_LOAD_COLOR for more information.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// When FreeType outputs a bitmap of a glyph, it really outputs an alpha
  /// coverage map.  If a pixel is completely covered by a filled-in
  /// outline, the bitmap contains 0xFF at that pixel, meaning that
  /// 0xFF/0xFF fraction of that pixel is covered, meaning the pixel is 100%
  /// black (or 0% bright).  If a pixel is only 50% covered (value 0x80),
  /// the pixel is made 50% black (50% bright or a middle shade of grey).
  /// 0% covered means 0% black (100% bright or white).
  ///
  /// On high-DPI screens like on smartphones and tablets, the pixels are so
  /// small that their chance of being completely covered and therefore
  /// completely black are fairly good.  On the low-DPI screens, however,
  /// the situation is different.  The pixels are too large for most of the
  /// details of a glyph and shades of gray are the norm rather than the
  /// exception.
  ///
  /// This is relevant because all our screens have a second problem: they
  /// are not linear.  1~+~1 is not~2.  Twice the value does not result in
  /// twice the brightness.  When a pixel is only 50% covered, the coverage
  /// map says 50% black, and this translates to a pixel value of 128 when
  /// you use 8~bits per channel (0-255).  However, this does not translate
  /// to 50% brightness for that pixel on our sRGB and gamma~2.2 screens.
  /// Due to their non-linearity, they dwell longer in the darks and only a
  /// pixel value of about 186 results in 50% brightness -- 128 ends up too
  /// dark on both bright and dark backgrounds.  The net result is that dark
  /// text looks burnt-out, pixely and blotchy on bright background, bright
  /// text too frail on dark backgrounds, and colored text on colored
  /// background (for example, red on green) seems to have dark halos or
  /// 'dirt' around it.  The situation is especially ugly for diagonal stems
  /// like in 'w' glyph shapes where the quality of FreeType's anti-aliasing
  /// depends on the correct display of grays.  On high-DPI screens where
  /// smaller, fully black pixels reign supreme, this doesn't matter, but on
  /// our low-DPI screens with all the gray shades, it does.  0% and 100%
  /// brightness are the same things in linear and non-linear space, just
  /// all the shades in-between aren't.
  ///
  /// The blending function for placing text over a background is
  ///
  /// ```
  /// dst = alpha * src + (1 - alpha) * dst    ,
  /// ```
  ///
  /// which is known as the OVER operator.
  ///
  /// To correctly composite an anti-aliased pixel of a glyph onto a
  /// surface,
  ///
  /// 1. take the foreground and background colors (e.g., in sRGB space)
  /// and apply gamma to get them in a linear space,
  ///
  /// 2. use OVER to blend the two linear colors using the glyph pixel
  /// as the alpha value (remember, the glyph bitmap is an alpha coverage
  /// bitmap), and
  ///
  /// 3. apply inverse gamma to the blended pixel and write it back to
  /// the image.
  ///
  /// Internal testing at Adobe found that a target inverse gamma of~1.8 for
  /// step~3 gives good results across a wide range of displays with an sRGB
  /// gamma curve or a similar one.
  ///
  /// This process can cost performance.  There is an approximation that
  /// does not need to know about the background color; see
  /// https://bel.fi/alankila/lcd/ and
  /// https://bel.fi/alankila/lcd/alpcor.html for details.
  ///
  /// **ATTENTION**: Linear blending is even more important when dealing
  /// with subpixel-rendered glyphs to prevent color-fringing!  A
  /// subpixel-rendered glyph must first be filtered with a filter that
  /// gives equal weight to the three color primaries and does not exceed a
  /// sum of 0x100, see section @lcd_rendering.  Then the only difference to
  /// gray linear blending is that subpixel-rendered linear blending is done
  /// 3~times per pixel: red foreground subpixel to red background subpixel
  /// and so on for green and blue.
  DartFT_Error FT_Render_Glyph(
    FT_GlyphSlot$1 slot,
    FT_Render_Mode_ render_mode,
  ) {
    return _FT_Render_Glyph(
      slot,
      render_mode.value,
    );
  }

  late final _FT_Render_GlyphPtr = _lookup<
          ffi
          .NativeFunction<FT_Error Function(FT_GlyphSlot$1, ffi.UnsignedInt)>>(
      'FT_Render_Glyph');
  late final _FT_Render_Glyph =
      _FT_Render_GlyphPtr.asFunction<int Function(FT_GlyphSlot$1, int)>();

  /// @function:
  /// FT_Get_Kerning
  ///
  /// @description:
  /// Return the kerning vector between two glyphs of the same face.
  ///
  /// @input:
  /// face ::
  /// A handle to a source face object.
  ///
  /// left_glyph ::
  /// The index of the left glyph in the kern pair.
  ///
  /// right_glyph ::
  /// The index of the right glyph in the kern pair.
  ///
  /// kern_mode ::
  /// See @FT_Kerning_Mode for more information.  Determines the scale and
  /// dimension of the returned kerning vector.
  ///
  /// @output:
  /// akerning ::
  /// The kerning vector.  This is either in font units, fractional pixels
  /// (26.6 format), or pixels for scalable formats, and in pixels for
  /// fixed-sizes formats.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Only horizontal layouts (left-to-right & right-to-left) are supported
  /// by this method.  Other layouts, or more sophisticated kernings, are
  /// out of the scope of this API function -- they can be implemented
  /// through format-specific interfaces.
  ///
  /// Note that, for TrueType fonts only, this can extract data from both
  /// the 'kern' table and the basic, pair-wise kerning feature from the
  /// GPOS table (with `TT_CONFIG_OPTION_GPOS_KERNING` enabled), though
  /// FreeType does not support the more advanced GPOS layout features; use
  /// a library like HarfBuzz for those instead.  If a font has both a
  /// 'kern' table and kern features of a GPOS table, the 'kern' table will
  /// be used.
  ///
  /// Also note for right-to-left scripts, the functionality may differ for
  /// fonts with GPOS tables vs. 'kern' tables.  For GPOS, right-to-left
  /// fonts typically use both a placement offset and an advance for pair
  /// positioning, which this API does not support, so it would output
  /// kerning values of zero; though if the right-to-left font used only
  /// advances in GPOS pair positioning, then this API could output kerning
  /// values for it, but it would use `left_glyph` to mean the first glyph
  /// for that case.  Whereas 'kern' tables are always advance-only and
  /// always store the left glyph first.
  ///
  /// Use @FT_HAS_KERNING to find out whether a font has data that can be
  /// extracted with `FT_Get_Kerning`.
  int FT_Get_Kerning(
    FT_Face face,
    int left_glyph,
    int right_glyph,
    int kern_mode,
    ffi.Pointer<FT_Vector_> akerning,
  ) {
    return _FT_Get_Kerning(
      face,
      left_glyph,
      right_glyph,
      kern_mode,
      akerning,
    );
  }

  late final _FT_Get_KerningPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_UInt, FT_UInt, FT_UInt,
              ffi.Pointer<FT_Vector_>)>>('FT_Get_Kerning');
  late final _FT_Get_Kerning = _FT_Get_KerningPtr.asFunction<
      int Function(FT_Face, int, int, int, ffi.Pointer<FT_Vector_>)>();

  /// @function:
  /// FT_Get_Track_Kerning
  ///
  /// @description:
  /// Return the track kerning for a given face object at a given size.
  ///
  /// @input:
  /// face ::
  /// A handle to a source face object.
  ///
  /// point_size ::
  /// The point size in 16.16 fractional points.
  ///
  /// degree ::
  /// The degree of tightness.  Increasingly negative values represent
  /// tighter track kerning, while increasingly positive values represent
  /// looser track kerning.  Value zero means no track kerning.
  ///
  /// @output:
  /// akerning ::
  /// The kerning in 16.16 fractional points, to be uniformly applied
  /// between all glyphs.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Currently, only the Type~1 font driver supports track kerning, using
  /// data from AFM files (if attached with @FT_Attach_File or
  /// @FT_Attach_Stream).
  ///
  /// Only very few AFM files come with track kerning data; please refer to
  /// Adobe's AFM specification for more details.
  int FT_Get_Track_Kerning(
    FT_Face face,
    int point_size,
    int degree,
    ffi.Pointer<FT_Fixed> akerning,
  ) {
    return _FT_Get_Track_Kerning(
      face,
      point_size,
      degree,
      akerning,
    );
  }

  late final _FT_Get_Track_KerningPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_Fixed, FT_Int,
              ffi.Pointer<FT_Fixed>)>>('FT_Get_Track_Kerning');
  late final _FT_Get_Track_Kerning = _FT_Get_Track_KerningPtr.asFunction<
      int Function(FT_Face, int, int, ffi.Pointer<FT_Fixed>)>();

  /// @function:
  /// FT_Select_Charmap
  ///
  /// @description:
  /// Select a given charmap by its encoding tag (as listed in
  /// `freetype.h`).
  ///
  /// @inout:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @input:
  /// encoding ::
  /// A handle to the selected encoding.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// This function returns an error if no charmap in the face corresponds
  /// to the encoding queried here.
  ///
  /// Because many fonts contain more than a single cmap for Unicode
  /// encoding, this function has some special code to select the one that
  /// covers Unicode best ('best' in the sense that a UCS-4 cmap is
  /// preferred to a UCS-2 cmap).  It is thus preferable to @FT_Set_Charmap
  /// in this case.
  DartFT_Error FT_Select_Charmap(
    FT_Face face,
    FT_Encoding_ encoding,
  ) {
    return _FT_Select_Charmap(
      face,
      encoding.value,
    );
  }

  late final _FT_Select_CharmapPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, ffi.UnsignedInt)>>(
          'FT_Select_Charmap');
  late final _FT_Select_Charmap =
      _FT_Select_CharmapPtr.asFunction<int Function(FT_Face, int)>();

  /// @function:
  /// FT_Set_Charmap
  ///
  /// @description:
  /// Select a given charmap for character code to glyph index mapping.
  ///
  /// @inout:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @input:
  /// charmap ::
  /// A handle to the selected charmap.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// This function returns an error if the charmap is not part of the face
  /// (i.e., if it is not listed in the `face->charmaps` table).
  ///
  /// It also fails if an OpenType type~14 charmap is selected (which
  /// doesn't map character codes to glyph indices at all).
  int FT_Set_Charmap(
    FT_Face face,
    FT_CharMap charmap,
  ) {
    return _FT_Set_Charmap(
      face,
      charmap,
    );
  }

  late final _FT_Set_CharmapPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_CharMap)>>(
          'FT_Set_Charmap');
  late final _FT_Set_Charmap =
      _FT_Set_CharmapPtr.asFunction<int Function(FT_Face, FT_CharMap)>();

  /// @function:
  /// FT_Get_Char_Index
  ///
  /// @description:
  /// Return the glyph index of a given character code.  This function uses
  /// the currently selected charmap to do the mapping.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// charcode ::
  /// The character code.
  ///
  /// @return:
  /// The glyph index.  0~means 'undefined character code'.
  ///
  /// @note:
  /// If you use FreeType to manipulate the contents of font files directly,
  /// be aware that the glyph index returned by this function doesn't always
  /// correspond to the internal indices used within the file.  This is done
  /// to ensure that value~0 always corresponds to the 'missing glyph'.  If
  /// the first glyph is not named '.notdef', then for Type~1 and Type~42
  /// fonts, '.notdef' will be moved into the glyph ID~0 position, and
  /// whatever was there will be moved to the position '.notdef' had.  For
  /// Type~1 fonts, if there is no '.notdef' glyph at all, then one will be
  /// created at index~0 and whatever was there will be moved to the last
  /// index -- Type~42 fonts are considered invalid under this condition.
  int FT_Get_Char_Index(
    FT_Face face,
    int charcode,
  ) {
    return _FT_Get_Char_Index(
      face,
      charcode,
    );
  }

  late final _FT_Get_Char_IndexPtr =
      _lookup<ffi.NativeFunction<FT_UInt Function(FT_Face, FT_ULong)>>(
          'FT_Get_Char_Index');
  late final _FT_Get_Char_Index =
      _FT_Get_Char_IndexPtr.asFunction<int Function(FT_Face, int)>();

  /// @function:
  /// FT_Get_First_Char
  ///
  /// @description:
  /// Return the first character code in the current charmap of a given
  /// face, together with its corresponding glyph index.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @output:
  /// agindex ::
  /// Glyph index of first character code.  0~if charmap is empty.
  ///
  /// @return:
  /// The charmap's first character code.
  ///
  /// @note:
  /// You should use this function together with @FT_Get_Next_Char to parse
  /// all character codes available in a given charmap.  The code should
  /// look like this:
  ///
  /// ```
  /// FT_ULong  charcode;
  /// FT_UInt   gindex;
  ///
  ///
  /// charcode = FT_Get_First_Char( face, &gindex );
  /// while ( gindex != 0 )
  /// {
  /// ... do something with (charcode,gindex) pair ...
  ///
  /// charcode = FT_Get_Next_Char( face, charcode, &gindex );
  /// }
  /// ```
  ///
  /// Be aware that character codes can have values up to 0xFFFFFFFF; this
  /// might happen for non-Unicode or malformed cmaps.  However, even with
  /// regular Unicode encoding, so-called 'last resort fonts' (using SFNT
  /// cmap format 13, see function @FT_Get_CMap_Format) normally have
  /// entries for all Unicode characters up to 0x1FFFFF, which can cause *a
  /// lot* of iterations.
  ///
  /// Note that `*agindex` is set to~0 if the charmap is empty.  The result
  /// itself can be~0 in two cases: if the charmap is empty or if the
  /// value~0 is the first valid character code.
  int FT_Get_First_Char(
    FT_Face face,
    ffi.Pointer<FT_UInt> agindex,
  ) {
    return _FT_Get_First_Char(
      face,
      agindex,
    );
  }

  late final _FT_Get_First_CharPtr = _lookup<
          ffi.NativeFunction<FT_ULong Function(FT_Face, ffi.Pointer<FT_UInt>)>>(
      'FT_Get_First_Char');
  late final _FT_Get_First_Char = _FT_Get_First_CharPtr.asFunction<
      int Function(FT_Face, ffi.Pointer<FT_UInt>)>();

  /// @function:
  /// FT_Get_Next_Char
  ///
  /// @description:
  /// Return the next character code in the current charmap of a given face
  /// following the value `char_code`, as well as the corresponding glyph
  /// index.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// char_code ::
  /// The starting character code.
  ///
  /// @output:
  /// agindex ::
  /// Glyph index of next character code.  0~if charmap is empty.
  ///
  /// @return:
  /// The charmap's next character code.
  ///
  /// @note:
  /// You should use this function with @FT_Get_First_Char to walk over all
  /// character codes available in a given charmap.  See the note for that
  /// function for a simple code example.
  ///
  /// Note that `*agindex` is set to~0 when there are no more codes in the
  /// charmap.
  int FT_Get_Next_Char(
    FT_Face face,
    int char_code,
    ffi.Pointer<FT_UInt> agindex,
  ) {
    return _FT_Get_Next_Char(
      face,
      char_code,
      agindex,
    );
  }

  late final _FT_Get_Next_CharPtr = _lookup<
      ffi.NativeFunction<
          FT_ULong Function(
              FT_Face, FT_ULong, ffi.Pointer<FT_UInt>)>>('FT_Get_Next_Char');
  late final _FT_Get_Next_Char = _FT_Get_Next_CharPtr.asFunction<
      int Function(FT_Face, int, ffi.Pointer<FT_UInt>)>();

  /// @function:
  /// FT_Get_Name_Index
  ///
  /// @description:
  /// Return the glyph index of a given glyph name.  This only works
  /// for those faces where @FT_HAS_GLYPH_NAMES returns true.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// glyph_name ::
  /// The glyph name.
  ///
  /// @return:
  /// The glyph index.  0~means 'undefined character code'.
  ///
  /// @note:
  /// Acceptable glyph names might come from the [Adobe Glyph
  /// List](https://github.com/adobe-type-tools/agl-aglfn).  See
  /// @FT_Get_Glyph_Name for the inverse functionality.
  ///
  /// This function has limited capabilities if the config macro
  /// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:
  /// It then works only for fonts that actually embed glyph names (which
  /// many recent OpenType fonts do not).
  int FT_Get_Name_Index(
    FT_Face face,
    ffi.Pointer<ffi.Char> glyph_name,
  ) {
    return _FT_Get_Name_Index(
      face,
      glyph_name,
    );
  }

  late final _FT_Get_Name_IndexPtr = _lookup<
          ffi.NativeFunction<FT_UInt Function(FT_Face, ffi.Pointer<ffi.Char>)>>(
      'FT_Get_Name_Index');
  late final _FT_Get_Name_Index = _FT_Get_Name_IndexPtr.asFunction<
      int Function(FT_Face, ffi.Pointer<ffi.Char>)>();

  /// @function:
  /// FT_Get_Glyph_Name
  ///
  /// @description:
  /// Retrieve the ASCII name of a given glyph in a face.  This only works
  /// for those faces where @FT_HAS_GLYPH_NAMES returns true.
  ///
  /// @input:
  /// face ::
  /// A handle to a source face object.
  ///
  /// glyph_index ::
  /// The glyph index.
  ///
  /// buffer_max ::
  /// The maximum number of bytes available in the buffer.
  ///
  /// @output:
  /// buffer ::
  /// A pointer to a target buffer where the name is copied to.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// An error is returned if the face doesn't provide glyph names or if the
  /// glyph index is invalid.  In all cases of failure, the first byte of
  /// `buffer` is set to~0 to indicate an empty name.
  ///
  /// The glyph name is truncated to fit within the buffer if it is too
  /// long.  The returned string is always zero-terminated.
  ///
  /// Be aware that FreeType reorders glyph indices internally so that glyph
  /// index~0 always corresponds to the 'missing glyph' (called '.notdef').
  ///
  /// This function has limited capabilities if the config macro
  /// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:
  /// It then works only for fonts that actually embed glyph names (which
  /// many recent OpenType fonts do not).
  int FT_Get_Glyph_Name(
    FT_Face face,
    int glyph_index,
    ffi.Pointer<ffi.Void> buffer,
    int buffer_max,
  ) {
    return _FT_Get_Glyph_Name(
      face,
      glyph_index,
      buffer,
      buffer_max,
    );
  }

  late final _FT_Get_Glyph_NamePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_UInt, ffi.Pointer<ffi.Void>,
              FT_UInt)>>('FT_Get_Glyph_Name');
  late final _FT_Get_Glyph_Name = _FT_Get_Glyph_NamePtr.asFunction<
      int Function(FT_Face, int, ffi.Pointer<ffi.Void>, int)>();

  /// @function:
  /// FT_Get_Postscript_Name
  ///
  /// @description:
  /// Retrieve the ASCII PostScript name of a given face, if available.
  /// This only works with PostScript, TrueType, and OpenType fonts.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @return:
  /// A pointer to the face's PostScript name.  `NULL` if unavailable.
  ///
  /// @note:
  /// The returned pointer is owned by the face and is destroyed with it.
  ///
  /// For variation fonts, this string changes if you select a different
  /// instance, and you have to call `FT_Get_PostScript_Name` again to
  /// retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating
  /// PostScript Names for Fonts Using OpenType Font Variations'.
  ///
  /// https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html
  ///
  /// [Since 2.9] Special PostScript names for named instances are only
  /// returned if the named instance is set with @FT_Set_Named_Instance (and
  /// the font has corresponding entries in its 'fvar' table or is the
  /// default named instance).  If @FT_IS_VARIATION returns true, the
  /// algorithmically derived PostScript name is provided, not looking up
  /// special entries for named instances.
  ffi.Pointer<ffi.Char> FT_Get_Postscript_Name(
    FT_Face face,
  ) {
    return _FT_Get_Postscript_Name(
      face,
    );
  }

  late final _FT_Get_Postscript_NamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(FT_Face)>>(
          'FT_Get_Postscript_Name');
  late final _FT_Get_Postscript_Name = _FT_Get_Postscript_NamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(FT_Face)>();

  /// @function:
  /// FT_Get_FSType_Flags
  ///
  /// @description:
  /// Return the `fsType` flags for a font.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @return:
  /// The `fsType` flags, see @FT_FSTYPE_XXX.
  ///
  /// @note:
  /// Use this function rather than directly reading the `fs_type` field in
  /// the @PS_FontInfoRec structure, which is only guaranteed to return the
  /// correct results for Type~1 fonts.
  ///
  /// @since:
  /// 2.3.8
  int FT_Get_FSType_Flags(
    FT_Face face,
  ) {
    return _FT_Get_FSType_Flags(
      face,
    );
  }

  late final _FT_Get_FSType_FlagsPtr =
      _lookup<ffi.NativeFunction<FT_UShort Function(FT_Face)>>(
          'FT_Get_FSType_Flags');
  late final _FT_Get_FSType_Flags =
      _FT_Get_FSType_FlagsPtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Library_Version
  ///
  /// @description:
  /// Return the version of the FreeType library being used.  This is useful
  /// when dynamically linking to the library, since one cannot use the
  /// macros @FREETYPE_MAJOR, @FREETYPE_MINOR, and @FREETYPE_PATCH.
  ///
  /// @input:
  /// library ::
  /// A source library handle.
  ///
  /// @output:
  /// amajor ::
  /// The major version number.
  ///
  /// aminor ::
  /// The minor version number.
  ///
  /// apatch ::
  /// The patch version number.
  ///
  /// @note:
  /// The reason why this function takes a `library` argument is because
  /// certain programs implement library initialization in a custom way that
  /// doesn't use @FT_Init_FreeType.
  ///
  /// In such cases, the library version might not be available before the
  /// library object has been created.
  void FT_Library_Version(
    FT_Library library$,
    ffi.Pointer<FT_Int> amajor,
    ffi.Pointer<FT_Int> aminor,
    ffi.Pointer<FT_Int> apatch,
  ) {
    return _FT_Library_Version(
      library$,
      amajor,
      aminor,
      apatch,
    );
  }

  late final _FT_Library_VersionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FT_Library, ffi.Pointer<FT_Int>,
              ffi.Pointer<FT_Int>, ffi.Pointer<FT_Int>)>>('FT_Library_Version');
  late final _FT_Library_Version = _FT_Library_VersionPtr.asFunction<
      void Function(FT_Library, ffi.Pointer<FT_Int>, ffi.Pointer<FT_Int>,
          ffi.Pointer<FT_Int>)>();
}

/// @struct:
/// FT_MemoryRec
///
/// @description:
/// A structure used to describe a given memory manager to FreeType~2.
///
/// @fields:
/// user ::
/// A generic typeless pointer for user data.
///
/// alloc ::
/// A pointer type to an allocation function.
///
/// free ::
/// A pointer type to an memory freeing function.
///
/// realloc ::
/// A pointer type to a reallocation function.
final class FT_MemoryRec_ extends ffi.Struct {
  external ffi.Pointer<ffi.Void> user;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<FT_MemoryRec_> memory, ffi.Long size)>> alloc;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FT_MemoryRec_> memory,
              ffi.Pointer<ffi.Void> block)>> free;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<FT_MemoryRec_> memory,
              ffi.Long cur_size,
              ffi.Long new_size,
              ffi.Pointer<ffi.Void> block)>> realloc;
}

/// @struct:
/// FT_StreamDesc
///
/// @description:
/// A union type used to store either a long or a pointer.  This is used
/// to store a file descriptor or a `FILE*` in an input stream.
final class FT_StreamDesc_ extends ffi.Union {
  @ffi.Long()
  external int value;

  external ffi.Pointer<ffi.Void> pointer;
}

/// @struct:
/// FT_StreamRec
///
/// @description:
/// A structure used to describe an input stream.
///
/// @input:
/// base ::
/// For memory-based streams, this is the address of the first stream
/// byte in memory.  This field should always be set to `NULL` for
/// disk-based streams.
///
/// size ::
/// The stream size in bytes.
///
/// In case of compressed streams where the size is unknown before
/// actually doing the decompression, the value is set to 0x7FFFFFFF.
/// (Note that this size value can occur for normal streams also; it is
/// thus just a hint.)
///
/// pos ::
/// The current position within the stream.
///
/// descriptor ::
/// This field is a union that can hold an integer or a pointer.  It is
/// used by stream implementations to store file descriptors or `FILE*`
/// pointers.
///
/// pathname ::
/// This field is completely ignored by FreeType.  However, it is often
/// useful during debugging to use it to store the stream's filename
/// (where available).
///
/// read ::
/// The stream's input function.
///
/// close ::
/// The stream's close function.
///
/// memory ::
/// The memory manager to use to preload frames.  This is set internally
/// by FreeType and shouldn't be touched by stream implementations.
///
/// cursor ::
/// This field is set and used internally by FreeType when parsing
/// frames.  In particular, the `FT_GET_XXX` macros use this instead of
/// the `pos` field.
///
/// limit ::
/// This field is set and used internally by FreeType when parsing
/// frames.
final class FT_StreamRec_ extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> base;

  @ffi.UnsignedLong()
  external int size;

  @ffi.UnsignedLong()
  external int pos;

  external FT_StreamDesc_ descriptor;

  external FT_StreamDesc_ pathname;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<FT_StreamRec_> stream,
              ffi.UnsignedLong offset,
              ffi.Pointer<ffi.UnsignedChar> buffer,
              ffi.UnsignedLong count)>> read;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<FT_StreamRec_> stream)>>
      close;

  external ffi.Pointer<FT_MemoryRec_> memory;

  external ffi.Pointer<ffi.UnsignedChar> cursor;

  external ffi.Pointer<ffi.UnsignedChar> limit;
}

/// @type:
/// FT_Pos
///
/// @description:
/// The type FT_Pos is used to store vectorial coordinates.  Depending on
/// the context, these can represent distances in integer font units, or
/// 16.16, or 26.6 fixed-point pixel coordinates.
typedef FT_Pos = ffi.Long;
typedef DartFT_Pos = int;

/// @struct:
/// FT_Vector
///
/// @description:
/// A simple structure used to store a 2D vector; coordinates are of the
/// FT_Pos type.
///
/// @fields:
/// x ::
/// The horizontal coordinate.
/// y ::
/// The vertical coordinate.
final class FT_Vector_ extends ffi.Struct {
  @FT_Pos()
  external int x;

  @FT_Pos()
  external int y;
}

/// @struct:
/// FT_BBox
///
/// @description:
/// A structure used to hold an outline's bounding box, i.e., the
/// coordinates of its extrema in the horizontal and vertical directions.
///
/// @fields:
/// xMin ::
/// The horizontal minimum (left-most).
///
/// yMin ::
/// The vertical minimum (bottom-most).
///
/// xMax ::
/// The horizontal maximum (right-most).
///
/// yMax ::
/// The vertical maximum (top-most).
///
/// @note:
/// The bounding box is specified with the coordinates of the lower left
/// and the upper right corner.  In PostScript, those values are often
/// called (llx,lly) and (urx,ury), respectively.
///
/// If `yMin` is negative, this value gives the glyph's descender.
/// Otherwise, the glyph doesn't descend below the baseline.  Similarly,
/// if `ymax` is positive, this value gives the glyph's ascender.
///
/// `xMin` gives the horizontal distance from the glyph's origin to the
/// left edge of the glyph's bounding box.  If `xMin` is negative, the
/// glyph extends to the left of the origin.
final class FT_BBox_ extends ffi.Struct {
  @FT_Pos()
  external int xMin;

  @FT_Pos()
  external int yMin;

  @FT_Pos()
  external int xMax;

  @FT_Pos()
  external int yMax;
}

/// @struct:
/// FT_Bitmap
///
/// @description:
/// A structure used to describe a bitmap or pixmap to the raster.  Note
/// that we now manage pixmaps of various depths through the `pixel_mode`
/// field.
///
/// @fields:
/// rows ::
/// The number of bitmap rows.
///
/// width ::
/// The number of pixels in bitmap row.
///
/// pitch ::
/// The pitch's absolute value is the number of bytes taken by one
/// bitmap row, including padding.  However, the pitch is positive when
/// the bitmap has a 'down' flow, and negative when it has an 'up' flow.
/// In all cases, the pitch is an offset to add to a bitmap pointer in
/// order to go down one row.
///
/// Note that 'padding' means the alignment of a bitmap to a byte
/// border, and FreeType functions normally align to the smallest
/// possible integer value.
///
/// For the B/W rasterizer, `pitch` is always an even number.
///
/// To change the pitch of a bitmap (say, to make it a multiple of 4),
/// use @FT_Bitmap_Convert.  Alternatively, you might use callback
/// functions to directly render to the application's surface; see the
/// file `example2.cpp` in the tutorial for a demonstration.
///
/// buffer ::
/// A typeless pointer to the bitmap buffer.  This value should be
/// aligned on 32-bit boundaries in most cases.
///
/// num_grays ::
/// This field is only used with @FT_PIXEL_MODE_GRAY; it gives the
/// number of gray levels used in the bitmap.
///
/// pixel_mode ::
/// The pixel mode, i.e., how pixel bits are stored.  See @FT_Pixel_Mode
/// for possible values.
///
/// palette_mode ::
/// This field is intended for paletted pixel modes; it indicates how
/// the palette is stored.  Not used currently.
///
/// palette ::
/// A typeless pointer to the bitmap palette; this field is intended for
/// paletted pixel modes.  Not used currently.
///
/// @note:
/// `width` and `rows` refer to the *physical* size of the bitmap, not the
/// *logical* one.  For example, if @FT_Pixel_Mode is set to
/// `FT_PIXEL_MODE_LCD`, the logical width is a just a third of the
/// physical one.
final class FT_Bitmap_ extends ffi.Struct {
  @ffi.UnsignedInt()
  external int rows;

  @ffi.UnsignedInt()
  external int width;

  @ffi.Int()
  external int pitch;

  external ffi.Pointer<ffi.UnsignedChar> buffer;

  @ffi.UnsignedShort()
  external int num_grays;

  @ffi.UnsignedChar()
  external int pixel_mode;

  @ffi.UnsignedChar()
  external int palette_mode;

  external ffi.Pointer<ffi.Void> palette;
}

/// @struct:
/// FT_Outline
///
/// @description:
/// This structure is used to describe an outline to the scan-line
/// converter.
///
/// @fields:
/// n_contours ::
/// The number of contours in the outline.
///
/// n_points ::
/// The number of points in the outline.
///
/// points ::
/// A pointer to an array of `n_points` @FT_Vector elements, giving the
/// outline's point coordinates.
///
/// tags ::
/// A pointer to an array of `n_points` chars, giving each outline
/// point's type.
///
/// If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier
/// control point, while it is 'on' if set.
///
/// Bit~1 is meaningful for 'off' points only.  If set, it indicates a
/// third-order Bezier arc control point; and a second-order control
/// point if unset.
///
/// If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in
/// the OpenType specification; the value is the same as the argument to
/// the 'SCANTYPE' instruction).
///
/// Bits 3 and~4 are reserved for internal purposes.
///
/// contours ::
/// An array of `n_contours` shorts, giving the end point of each
/// contour within the outline.  For example, the first contour is
/// defined by the points '0' to `contours[0]`, the second one is
/// defined by the points `contours[0]+1` to `contours[1]`, etc.
///
/// flags ::
/// A set of bit flags used to characterize the outline and give hints
/// to the scan-converter and hinter on how to convert/grid-fit it.  See
/// @FT_OUTLINE_XXX.
///
/// @note:
/// The B/W rasterizer only checks bit~2 in the `tags` array for the first
/// point of each contour.  The drop-out mode as given with
/// @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and
/// @FT_OUTLINE_INCLUDE_STUBS in `flags` is then overridden.
final class FT_Outline_ extends ffi.Struct {
  @ffi.UnsignedShort()
  external int n_contours;

  @ffi.UnsignedShort()
  external int n_points;

  external ffi.Pointer<FT_Vector_> points;

  external ffi.Pointer<ffi.UnsignedChar> tags;

  external ffi.Pointer<ffi.UnsignedShort> contours;

  @ffi.Int()
  external int flags;
}

/// @enum:
/// FT_Glyph_Format
///
/// @description:
/// An enumeration type used to describe the format of a given glyph
/// image.  Note that this version of FreeType only supports two image
/// formats, even though future font drivers will be able to register
/// their own format.
///
/// @values:
/// FT_GLYPH_FORMAT_NONE ::
/// The value~0 is reserved.
///
/// FT_GLYPH_FORMAT_COMPOSITE ::
/// The glyph image is a composite of several other images.  This format
/// is _only_ used with @FT_LOAD_NO_RECURSE, and is used to report
/// compound glyphs (like accented characters).
///
/// FT_GLYPH_FORMAT_BITMAP ::
/// The glyph image is a bitmap, and can be described as an @FT_Bitmap.
/// You generally need to access the `bitmap` field of the
/// @FT_GlyphSlotRec structure to read it.
///
/// FT_GLYPH_FORMAT_OUTLINE ::
/// The glyph image is a vectorial outline made of line segments and
/// Bezier arcs; it can be described as an @FT_Outline; you generally
/// want to access the `outline` field of the @FT_GlyphSlotRec structure
/// to read it.
///
/// FT_GLYPH_FORMAT_PLOTTER ::
/// The glyph image is a vectorial path with no inside and outside
/// contours.  Some Type~1 fonts, like those in the Hershey family,
/// contain glyphs in this format.  These are described as @FT_Outline,
/// but FreeType isn't currently capable of rendering them correctly.
///
/// FT_GLYPH_FORMAT_SVG ::
/// [Since 2.12] The glyph is represented by an SVG document in the
/// 'SVG~' table.
enum FT_Glyph_Format_ {
  FT_GLYPH_FORMAT_NONE(0),
  FT_GLYPH_FORMAT_COMPOSITE(1668246896),
  FT_GLYPH_FORMAT_BITMAP(1651078259),
  FT_GLYPH_FORMAT_OUTLINE(1869968492),
  FT_GLYPH_FORMAT_PLOTTER(1886154612),
  FT_GLYPH_FORMAT_SVG(1398163232);

  final int value;
  const FT_Glyph_Format_(this.value);

  static FT_Glyph_Format_ fromValue(int value) => switch (value) {
        0 => FT_GLYPH_FORMAT_NONE,
        1668246896 => FT_GLYPH_FORMAT_COMPOSITE,
        1651078259 => FT_GLYPH_FORMAT_BITMAP,
        1869968492 => FT_GLYPH_FORMAT_OUTLINE,
        1886154612 => FT_GLYPH_FORMAT_PLOTTER,
        1398163232 => FT_GLYPH_FORMAT_SVG,
        _ => throw ArgumentError('Unknown value for FT_Glyph_Format_: $value'),
      };
}

/// @type:
/// FT_Short
///
/// @description:
/// A typedef for signed short.
typedef FT_Short = ffi.Short;
typedef DartFT_Short = int;

/// @type:
/// FT_UShort
///
/// @description:
/// A typedef for unsigned short.
typedef FT_UShort = ffi.UnsignedShort;
typedef DartFT_UShort = int;

/// @type:
/// FT_Int
///
/// @description:
/// A typedef for the int type.
typedef FT_Int = ffi.Int;
typedef DartFT_Int = int;

/// @type:
/// FT_UInt
///
/// @description:
/// A typedef for the unsigned int type.
typedef FT_UInt = ffi.UnsignedInt;
typedef DartFT_UInt = int;

/// @type:
/// FT_Long
///
/// @description:
/// A typedef for signed long.
typedef FT_Long = ffi.Long;
typedef DartFT_Long = int;

/// @type:
/// FT_ULong
///
/// @description:
/// A typedef for unsigned long.
typedef FT_ULong = ffi.UnsignedLong;
typedef DartFT_ULong = int;

/// @type:
/// FT_F26Dot6
///
/// @description:
/// A signed 26.6 fixed-point type used for vectorial pixel coordinates.
typedef FT_F26Dot6 = ffi.Long;
typedef DartFT_F26Dot6 = int;

/// @type:
/// FT_Fixed
///
/// @description:
/// This type is used to store 16.16 fixed-point values, like scaling
/// values or matrix coefficients.
typedef FT_Fixed = ffi.Long;
typedef DartFT_Fixed = int;

/// @type:
/// FT_Error
///
/// @description:
/// The FreeType error code type.  A value of~0 is always interpreted as a
/// successful operation.
typedef FT_Error = ffi.Int;
typedef DartFT_Error = int;

/// @struct:
/// FT_Matrix
///
/// @description:
/// A simple structure used to store a 2x2 matrix.  Coefficients are in
/// 16.16 fixed-point format.  The computation performed is:
///
/// ```
/// x' = x*xx + y*xy
/// y' = x*yx + y*yy
/// ```
///
/// @fields:
/// xx ::
/// Matrix coefficient.
///
/// xy ::
/// Matrix coefficient.
///
/// yx ::
/// Matrix coefficient.
///
/// yy ::
/// Matrix coefficient.
final class FT_Matrix_ extends ffi.Struct {
  @FT_Fixed()
  external int xx;

  @FT_Fixed()
  external int xy;

  @FT_Fixed()
  external int yx;

  @FT_Fixed()
  external int yy;
}

/// @struct:
/// FT_Generic
///
/// @description:
/// Client applications often need to associate their own data to a
/// variety of FreeType core objects.  For example, a text layout API
/// might want to associate a glyph cache to a given size object.
///
/// Some FreeType object contains a `generic` field, of type `FT_Generic`,
/// which usage is left to client applications and font servers.
///
/// It can be used to store a pointer to client-specific data, as well as
/// the address of a 'finalizer' function, which will be called by
/// FreeType when the object is destroyed (for example, the previous
/// client example would put the address of the glyph cache destructor in
/// the `finalizer` field).
///
/// @fields:
/// data ::
/// A typeless pointer to any client-specified data. This field is
/// completely ignored by the FreeType library.
///
/// finalizer ::
/// A pointer to a 'generic finalizer' function, which will be called
/// when the object is destroyed.  If this field is set to `NULL`, no
/// code will be called.
final class FT_Generic_ extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> object)>>
      finalizer;
}

/// @struct:
/// FT_ListNodeRec
///
/// @description:
/// A structure used to hold a single list element.
///
/// @fields:
/// prev ::
/// The previous element in the list.  `NULL` if first.
///
/// next ::
/// The next element in the list.  `NULL` if last.
///
/// data ::
/// A typeless pointer to the listed object.
final class FT_ListNodeRec_ extends ffi.Struct {
  external ffi.Pointer<FT_ListNodeRec_> prev;

  external ffi.Pointer<FT_ListNodeRec_> next;

  external ffi.Pointer<ffi.Void> data;
}

/// @struct:
/// FT_ListRec
///
/// @description:
/// A structure used to hold a simple doubly-linked list.  These are used
/// in many parts of FreeType.
///
/// @fields:
/// head ::
/// The head (first element) of doubly-linked list.
///
/// tail ::
/// The tail (last element) of doubly-linked list.
final class FT_ListRec_ extends ffi.Struct {
  external ffi.Pointer<FT_ListNodeRec_> head;

  external ffi.Pointer<FT_ListNodeRec_> tail;
}

/// @struct:
/// FT_Glyph_Metrics
///
/// @description:
/// A structure to model the metrics of a single glyph.  The values are
/// expressed in 26.6 fractional pixel format; if the flag
/// @FT_LOAD_NO_SCALE has been used while loading the glyph, values are
/// expressed in font units instead.
///
/// @fields:
/// width ::
/// The glyph's width.
///
/// height ::
/// The glyph's height.
///
/// horiBearingX ::
/// Left side bearing for horizontal layout.
///
/// horiBearingY ::
/// Top side bearing for horizontal layout.
///
/// horiAdvance ::
/// Advance width for horizontal layout.
///
/// vertBearingX ::
/// Left side bearing for vertical layout.
///
/// vertBearingY ::
/// Top side bearing for vertical layout.  Larger positive values mean
/// further below the vertical glyph origin.
///
/// vertAdvance ::
/// Advance height for vertical layout.  Positive values mean the glyph
/// has a positive advance downward.
///
/// @note:
/// If not disabled with @FT_LOAD_NO_HINTING, the values represent
/// dimensions of the hinted glyph (in case hinting is applicable).
///
/// Stroking a glyph with an outside border does not increase
/// `horiAdvance` or `vertAdvance`; you have to manually adjust these
/// values to account for the added width and height.
///
/// FreeType doesn't use the 'VORG' table data for CFF fonts because it
/// doesn't have an interface to quickly retrieve the glyph height.  The
/// y~coordinate of the vertical origin can be simply computed as
/// `vertBearingY + height` after loading a glyph.
final class FT_Glyph_Metrics_ extends ffi.Struct {
  @FT_Pos()
  external int width;

  @FT_Pos()
  external int height;

  @FT_Pos()
  external int horiBearingX;

  @FT_Pos()
  external int horiBearingY;

  @FT_Pos()
  external int horiAdvance;

  @FT_Pos()
  external int vertBearingX;

  @FT_Pos()
  external int vertBearingY;

  @FT_Pos()
  external int vertAdvance;
}

/// @struct:
/// FT_Bitmap_Size
///
/// @description:
/// This structure models the metrics of a bitmap strike (i.e., a set of
/// glyphs for a given point size and resolution) in a bitmap font.  It is
/// used for the `available_sizes` field of @FT_Face.
///
/// @fields:
/// height ::
/// The vertical distance, in pixels, between two consecutive baselines.
/// It is always positive.
///
/// width ::
/// The average width, in pixels, of all glyphs in the strike.
///
/// size ::
/// The nominal size of the strike in 26.6 fractional points.  This
/// field is not very useful.
///
/// x_ppem ::
/// The horizontal ppem (nominal width) in 26.6 fractional pixels.
///
/// y_ppem ::
/// The vertical ppem (nominal height) in 26.6 fractional pixels.
///
/// @note:
/// Windows FNT:
/// The nominal size given in a FNT font is not reliable.  If the driver
/// finds it incorrect, it sets `size` to some calculated values, and
/// `x_ppem` and `y_ppem` to the pixel width and height given in the
/// font, respectively.
///
/// TrueType embedded bitmaps:
/// `size`, `width`, and `height` values are not contained in the bitmap
/// strike itself.  They are computed from the global font parameters.
final class FT_Bitmap_Size_ extends ffi.Struct {
  @FT_Short()
  external int height;

  @FT_Short()
  external int width;

  @FT_Pos()
  external int size;

  @FT_Pos()
  external int x_ppem;

  @FT_Pos()
  external int y_ppem;
}

final class FT_LibraryRec_ extends ffi.Opaque {}

/// @type:
/// FT_Library
///
/// @description:
/// A handle to a FreeType library instance.  Each 'library' is completely
/// independent from the others; it is the 'root' of a set of objects like
/// fonts, faces, sizes, etc.
///
/// It also embeds a memory manager (see @FT_Memory), as well as a
/// scan-line converter object (see @FT_Raster).
///
/// [Since 2.5.6] In multi-threaded applications it is easiest to use one
/// `FT_Library` object per thread.  In case this is too cumbersome, a
/// single `FT_Library` object across threads is possible also, as long as
/// a mutex lock is used around @FT_New_Face and @FT_Done_Face.
///
/// @note:
/// Library objects are normally created by @FT_Init_FreeType, and
/// destroyed with @FT_Done_FreeType.  If you need reference-counting
/// (cf. @FT_Reference_Library), use @FT_New_Library and @FT_Done_Library.
typedef FT_Library = ffi.Pointer<FT_LibraryRec_>;

final class FT_DriverRec_ extends ffi.Opaque {}

/// @type:
/// FT_Face
///
/// @description:
/// A handle to a typographic face object.  A face object models a given
/// typeface, in a given style.
///
/// @note:
/// A face object also owns a single @FT_GlyphSlot object, as well as one
/// or more @FT_Size objects.
///
/// Use @FT_New_Face or @FT_Open_Face to create a new face object from a
/// given filepath or a custom input stream.
///
/// Use @FT_Done_Face to destroy it (along with its slot and sizes).
///
/// An `FT_Face` object can only be safely used from one thread at a time.
/// Similarly, creation and destruction of `FT_Face` with the same
/// @FT_Library object can only be done from one thread at a time.  On the
/// other hand, functions like @FT_Load_Glyph and its siblings are
/// thread-safe and do not need the lock to be held as long as the same
/// `FT_Face` object is not used from multiple threads at the same time.
///
/// @also:
/// See @FT_FaceRec for the publicly accessible fields of a given face
/// object.
typedef FT_Face = ffi.Pointer<FT_FaceRec_>;

/// @enum:
/// FT_Encoding
///
/// @description:
/// An enumeration to specify character sets supported by charmaps.  Used
/// in the @FT_Select_Charmap API function.
///
/// @note:
/// Despite the name, this enumeration lists specific character
/// repertoires (i.e., charsets), and not text encoding methods (e.g.,
/// UTF-8, UTF-16, etc.).
///
/// Other encodings might be defined in the future.
///
/// @values:
/// FT_ENCODING_NONE ::
/// The encoding value~0 is reserved for all formats except BDF, PCF,
/// and Windows FNT; see below for more information.
///
/// FT_ENCODING_UNICODE ::
/// The Unicode character set.  This value covers all versions of the
/// Unicode repertoire, including ASCII and Latin-1.  Most fonts include
/// a Unicode charmap, but not all of them.
///
/// For example, if you want to access Unicode value U+1F028 (and the
/// font contains it), use value 0x1F028 as the input value for
/// @FT_Get_Char_Index.
///
/// FT_ENCODING_MS_SYMBOL ::
/// Microsoft Symbol encoding, used to encode mathematical symbols and
/// wingdings.  For more information, see
/// 'https://www.microsoft.com/typography/otspec/recom.htm#non-standard-symbol-fonts',
/// 'http://www.kostis.net/charsets/symbol.htm', and
/// 'http://www.kostis.net/charsets/wingding.htm'.
///
/// This encoding uses character codes from the PUA (Private Unicode
/// Area) in the range U+F020-U+F0FF.
///
/// FT_ENCODING_SJIS ::
/// Shift JIS encoding for Japanese.  More info at
/// 'https://en.wikipedia.org/wiki/Shift_JIS'.  See note on multi-byte
/// encodings below.
///
/// FT_ENCODING_PRC ::
/// Corresponds to encoding systems mainly for Simplified Chinese as
/// used in People's Republic of China (PRC).  The encoding layout is
/// based on GB~2312 and its supersets GBK and GB~18030.
///
/// FT_ENCODING_BIG5 ::
/// Corresponds to an encoding system for Traditional Chinese as used in
/// Taiwan and Hong Kong.
///
/// FT_ENCODING_WANSUNG ::
/// Corresponds to the Korean encoding system known as Extended Wansung
/// (MS Windows code page 949).  For more information see
/// 'https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'.
///
/// FT_ENCODING_JOHAB ::
/// The Korean standard character set (KS~C 5601-1992), which
/// corresponds to MS Windows code page 1361.  This character set
/// includes all possible Hangul character combinations.
///
/// FT_ENCODING_ADOBE_LATIN_1 ::
/// Corresponds to a Latin-1 encoding as defined in a Type~1 PostScript
/// font.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_STANDARD ::
/// Adobe Standard encoding, as found in Type~1, CFF, and OpenType/CFF
/// fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_EXPERT ::
/// Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF
/// fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_CUSTOM ::
/// Corresponds to a custom encoding, as found in Type~1, CFF, and
/// OpenType/CFF fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_APPLE_ROMAN ::
/// Apple roman encoding.  Many TrueType and OpenType fonts contain a
/// charmap for this 8-bit encoding, since older versions of Mac OS are
/// able to use it.
///
/// FT_ENCODING_OLD_LATIN_2 ::
/// This value is deprecated and was neither used nor reported by
/// FreeType.  Don't use or test for it.
///
/// FT_ENCODING_MS_SJIS ::
/// Same as FT_ENCODING_SJIS.  Deprecated.
///
/// FT_ENCODING_MS_GB2312 ::
/// Same as FT_ENCODING_PRC.  Deprecated.
///
/// FT_ENCODING_MS_BIG5 ::
/// Same as FT_ENCODING_BIG5.  Deprecated.
///
/// FT_ENCODING_MS_WANSUNG ::
/// Same as FT_ENCODING_WANSUNG.  Deprecated.
///
/// FT_ENCODING_MS_JOHAB ::
/// Same as FT_ENCODING_JOHAB.  Deprecated.
///
/// @note:
/// When loading a font, FreeType makes a Unicode charmap active if
/// possible (either if the font provides such a charmap, or if FreeType
/// can synthesize one from PostScript glyph name dictionaries; in either
/// case, the charmap is tDartGraphicsed with `FT_ENCODING_UNICODE`).  If such a
/// charmap is synthesized, it is placed at the first position of the
/// charmap array.
///
/// All other encodings are considered legacy and tDartGraphicsed only if
/// explicitly defined in the font file.  Otherwise, `FT_ENCODING_NONE` is
/// used.
///
/// `FT_ENCODING_NONE` is set by the BDF and PCF drivers if the charmap is
/// neither Unicode nor ISO-8859-1 (otherwise it is set to
/// `FT_ENCODING_UNICODE`).  Use @FT_Get_BDF_Charset_ID to find out which
/// encoding is really present.  If, for example, the `cs_registry` field
/// is 'KOI8' and the `cs_encoding` field is 'R', the font is encoded in
/// KOI8-R.
///
/// `FT_ENCODING_NONE` is always set (with a single exception) by the
/// winfonts driver.  Use @FT_Get_WinFNT_Header and examine the `charset`
/// field of the @FT_WinFNT_HeaderRec structure to find out which encoding
/// is really present.  For example, @FT_WinFNT_ID_CP1251 (204) means
/// Windows code page 1251 (for Russian).
///
/// `FT_ENCODING_NONE` is set if `platform_id` is @TT_PLATFORM_MACINTOSH
/// and `encoding_id` is not `TT_MAC_ID_ROMAN` (otherwise it is set to
/// `FT_ENCODING_APPLE_ROMAN`).
///
/// If `platform_id` is @TT_PLATFORM_MACINTOSH, use the function
/// @FT_Get_CMap_Language_ID to query the Mac language ID that may be
/// needed to be able to distinguish Apple encoding variants.  See
///
/// https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
///
/// to get an idea how to do that.  Basically, if the language ID is~0,
/// don't use it, otherwise subtract 1 from the language ID.  Then examine
/// `encoding_id`.  If, for example, `encoding_id` is `TT_MAC_ID_ROMAN`
/// and the language ID (minus~1) is `TT_MAC_LANGID_GREEK`, it is the
/// Greek encoding, not Roman.  `TT_MAC_ID_ARABIC` with
/// `TT_MAC_LANGID_FARSI` means the Farsi variant of the Arabic encoding.
enum FT_Encoding_ {
  FT_ENCODING_NONE(0),
  FT_ENCODING_MS_SYMBOL(1937337698),
  FT_ENCODING_UNICODE(1970170211),
  FT_ENCODING_SJIS(1936353651),
  FT_ENCODING_PRC(1734484000),
  FT_ENCODING_BIG5(1651074869),
  FT_ENCODING_WANSUNG(2002873971),
  FT_ENCODING_JOHAB(1785686113),
  FT_ENCODING_ADOBE_STANDARD(1094995778),
  FT_ENCODING_ADOBE_EXPERT(1094992453),
  FT_ENCODING_ADOBE_CUSTOM(1094992451),
  FT_ENCODING_ADOBE_LATIN_1(1818326065),
  FT_ENCODING_OLD_LATIN_2(1818326066),
  FT_ENCODING_APPLE_ROMAN(1634889070);

  static const FT_ENCODING_GB2312 = FT_ENCODING_PRC;
  static const FT_ENCODING_MS_SJIS = FT_ENCODING_SJIS;
  static const FT_ENCODING_MS_GB2312 = FT_ENCODING_PRC;
  static const FT_ENCODING_MS_BIG5 = FT_ENCODING_BIG5;
  static const FT_ENCODING_MS_WANSUNG = FT_ENCODING_WANSUNG;
  static const FT_ENCODING_MS_JOHAB = FT_ENCODING_JOHAB;

  final int value;
  const FT_Encoding_(this.value);

  static FT_Encoding_ fromValue(int value) => switch (value) {
        0 => FT_ENCODING_NONE,
        1937337698 => FT_ENCODING_MS_SYMBOL,
        1970170211 => FT_ENCODING_UNICODE,
        1936353651 => FT_ENCODING_SJIS,
        1734484000 => FT_ENCODING_PRC,
        1651074869 => FT_ENCODING_BIG5,
        2002873971 => FT_ENCODING_WANSUNG,
        1785686113 => FT_ENCODING_JOHAB,
        1094995778 => FT_ENCODING_ADOBE_STANDARD,
        1094992453 => FT_ENCODING_ADOBE_EXPERT,
        1094992451 => FT_ENCODING_ADOBE_CUSTOM,
        1818326065 => FT_ENCODING_ADOBE_LATIN_1,
        1818326066 => FT_ENCODING_OLD_LATIN_2,
        1634889070 => FT_ENCODING_APPLE_ROMAN,
        _ => throw ArgumentError('Unknown value for FT_Encoding_: $value'),
      };

  @override
  String toString() {
    if (this == FT_ENCODING_SJIS)
      return "FT_Encoding_.FT_ENCODING_SJIS, FT_Encoding_.FT_ENCODING_MS_SJIS";
    if (this == FT_ENCODING_PRC)
      return "FT_Encoding_.FT_ENCODING_PRC, FT_Encoding_.FT_ENCODING_GB2312, FT_Encoding_.FT_ENCODING_MS_GB2312";
    if (this == FT_ENCODING_BIG5)
      return "FT_Encoding_.FT_ENCODING_BIG5, FT_Encoding_.FT_ENCODING_MS_BIG5";
    if (this == FT_ENCODING_WANSUNG)
      return "FT_Encoding_.FT_ENCODING_WANSUNG, FT_Encoding_.FT_ENCODING_MS_WANSUNG";
    if (this == FT_ENCODING_JOHAB)
      return "FT_Encoding_.FT_ENCODING_JOHAB, FT_Encoding_.FT_ENCODING_MS_JOHAB";
    return super.toString();
  }
}

/// @struct:
/// FT_CharMapRec
///
/// @description:
/// The base charmap structure.
///
/// @fields:
/// face ::
/// A handle to the parent face object.
///
/// encoding ::
/// An @FT_Encoding tag identifying the charmap.  Use this with
/// @FT_Select_Charmap.
///
/// platform_id ::
/// An ID number describing the platform for the following encoding ID.
/// This comes directly from the TrueType specification and gets
/// emulated for other formats.
///
/// encoding_id ::
/// A platform-specific encoding number.  This also comes from the
/// TrueType specification and gets emulated similarly.
final class FT_CharMapRec_ extends ffi.Struct {
  external FT_Face face;

  @ffi.UnsignedInt()
  external int encodingAsInt;

  FT_Encoding_ get encoding => FT_Encoding_.fromValue(encodingAsInt);

  @FT_UShort()
  external int platform_id;

  @FT_UShort()
  external int encoding_id;
}

/// @type:
/// FT_CharMap
///
/// @description:
/// A handle to a character map (usually abbreviated to 'charmap').  A
/// charmap is used to translate character codes in a given encoding into
/// glyph indexes for its parent's face.  Some font formats may provide
/// several charmaps per font.
///
/// Each face object owns zero or more charmaps, but only one of them can
/// be 'active', providing the data used by @FT_Get_Char_Index or
/// @FT_Load_Char.
///
/// The list of available charmaps in a face is available through the
/// `face->num_charmaps` and `face->charmaps` fields of @FT_FaceRec.
///
/// The currently active charmap is available as `face->charmap`.  You
/// should call @FT_Set_Charmap to change it.
///
/// @note:
/// When a new face is created (either through @FT_New_Face or
/// @FT_Open_Face), the library looks for a Unicode charmap within the
/// list and automatically activates it.  If there is no Unicode charmap,
/// FreeType doesn't set an 'active' charmap.
///
/// @also:
/// See @FT_CharMapRec for the publicly accessible fields of a given
/// character map.
typedef FT_CharMap = ffi.Pointer<FT_CharMapRec_>;

/// @type:
/// FT_GlyphSlot
///
/// @description:
/// A handle to a given 'glyph slot'.  A slot is a container that can hold
/// any of the glyphs contained in its parent face.
///
/// In other words, each time you call @FT_Load_Glyph or @FT_Load_Char,
/// the slot's content is erased by the new glyph data, i.e., the glyph's
/// metrics, its image (bitmap or outline), and other control information.
///
/// @also:
/// See @FT_GlyphSlotRec for the publicly accessible glyph fields.
typedef FT_GlyphSlot = ffi.Pointer<FT_GlyphSlotRec_>;

final class FT_SubGlyphRec_ extends ffi.Opaque {}

final class FT_Slot_InternalRec_ extends ffi.Opaque {}

/// @struct:
/// FT_GlyphSlotRec
///
/// @description:
/// FreeType root glyph slot class structure.  A glyph slot is a container
/// where individual glyphs can be loaded, be they in outline or bitmap
/// format.
///
/// @fields:
/// library ::
/// A handle to the FreeType library instance this slot belongs to.
///
/// face ::
/// A handle to the parent face object.
///
/// next ::
/// In some cases (like some font tools), several glyph slots per face
/// object can be a good thing.  As this is rare, the glyph slots are
/// listed through a direct, single-linked list using its `next` field.
///
/// glyph_index ::
/// [Since 2.10] The glyph index passed as an argument to @FT_Load_Glyph
/// while initializing the glyph slot.
///
/// generic ::
/// A typeless pointer unused by the FreeType library or any of its
/// drivers.  It can be used by client applications to link their own
/// data to each glyph slot object.
///
/// metrics ::
/// The metrics of the last loaded glyph in the slot.  The returned
/// values depend on the last load flags (see the @FT_Load_Glyph API
/// function) and can be expressed either in 26.6 fractional pixels or
/// font units.
///
/// Note that even when the glyph image is transformed, the metrics are
/// not.
///
/// linearHoriAdvance ::
/// The advance width of the unhinted glyph.  Its value is expressed in
/// 16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when
/// loading the glyph.  This field can be important to perform correct
/// WYSIWYG layout.  Only relevant for scalable glyphs.
///
/// linearVertAdvance ::
/// The advance height of the unhinted glyph.  Its value is expressed in
/// 16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when
/// loading the glyph.  This field can be important to perform correct
/// WYSIWYG layout.  Only relevant for scalable glyphs.
///
/// advance ::
/// This shorthand is, depending on @FT_LOAD_IGNORE_TRANSFORM, the
/// transformed (hinted) advance width for the glyph, in 26.6 fractional
/// pixel format.  As specified with @FT_LOAD_VERTICAL_LAYOUT, it uses
/// either the `horiAdvance` or the `vertAdvance` value of `metrics`
/// field.
///
/// format ::
/// This field indicates the format of the image contained in the glyph
/// slot.  Typically @FT_GLYPH_FORMAT_BITMAP, @FT_GLYPH_FORMAT_OUTLINE,
/// or @FT_GLYPH_FORMAT_COMPOSITE, but other values are possible.
///
/// bitmap ::
/// This field is used as a bitmap descriptor.  Note that the address
/// and content of the bitmap buffer can change between calls of
/// @FT_Load_Glyph and a few other functions.
///
/// bitmap_left ::
/// The bitmap's left bearing expressed in integer pixels.
///
/// bitmap_top ::
/// The bitmap's top bearing expressed in integer pixels.  This is the
/// distance from the baseline to the top-most glyph scanline, upwards
/// y~coordinates being **positive**.
///
/// outline ::
/// The outline descriptor for the current glyph image if its format is
/// @FT_GLYPH_FORMAT_OUTLINE.  Once a glyph is loaded, `outline` can be
/// transformed, distorted, emboldened, etc.  However, it must not be
/// freed.
///
/// [Since 2.10.1] If @FT_LOAD_NO_SCALE is set, outline coordinates of
/// OpenType variation fonts for a selected instance are internally
/// handled as 26.6 fractional font units but returned as (rounded)
/// integers, as expected.  To get unrounded font units, don't use
/// @FT_LOAD_NO_SCALE but load the glyph with @FT_LOAD_NO_HINTING and
/// scale it, using the font's `units_per_EM` value as the ppem.
///
/// num_subglyphs ::
/// The number of subglyphs in a composite glyph.  This field is only
/// valid for the composite glyph format that should normally only be
/// loaded with the @FT_LOAD_NO_RECURSE flag.
///
/// subglyphs ::
/// An array of subglyph descriptors for composite glyphs.  There are
/// `num_subglyphs` elements in there.  Currently internal to FreeType.
///
/// control_data ::
/// Certain font drivers can also return the control data for a given
/// glyph image (e.g.  TrueType bytecode, Type~1 charstrings, etc.).
/// This field is a pointer to such data; it is currently internal to
/// FreeType.
///
/// control_len ::
/// This is the length in bytes of the control data.  Currently internal
/// to FreeType.
///
/// other ::
/// Reserved.
///
/// lsb_delta ::
/// The difference between hinted and unhinted left side bearing while
/// auto-hinting is active.  Zero otherwise.
///
/// rsb_delta ::
/// The difference between hinted and unhinted right side bearing while
/// auto-hinting is active.  Zero otherwise.
///
/// @note:
/// If @FT_Load_Glyph is called with default flags (see @FT_LOAD_DEFAULT)
/// the glyph image is loaded in the glyph slot in its native format
/// (e.g., an outline glyph for TrueType and Type~1 formats).  [Since 2.9]
/// The prospective bitmap metrics are calculated according to
/// @FT_LOAD_TARGET_XXX and other flags even for the outline glyph, even
/// if @FT_LOAD_RENDER is not set.
///
/// This image can later be converted into a bitmap by calling
/// @FT_Render_Glyph.  This function searches the current renderer for the
/// native image's format, then invokes it.
///
/// The renderer is in charge of transforming the native image through the
/// slot's face transformation fields, then converting it into a bitmap
/// that is returned in `slot->bitmap`.
///
/// Note that `slot->bitmap_left` and `slot->bitmap_top` are also used to
/// specify the position of the bitmap relative to the current pen
/// position (e.g., coordinates (0,0) on the baseline).  Of course,
/// `slot->format` is also changed to @FT_GLYPH_FORMAT_BITMAP.
///
/// Here is a small pseudo code fragment that shows how to use `lsb_delta`
/// and `rsb_delta` to do fractional positioning of glyphs:
///
/// ```
/// FT_GlyphSlot  slot     = face->glyph;
/// FT_Pos        origin_x = 0;
///
///
/// for all glyphs do
/// <load glyph with `FT_Load_Glyph'>
///
/// FT_Outline_Translate( slot->outline, origin_x & 63, 0 );
///
/// <save glyph image, or render glyph, or ...>
///
/// <compute kern between current and next glyph
/// and add it to `origin_x'>
///
/// origin_x += slot->advance.x;
/// origin_x += slot->lsb_delta - slot->rsb_delta;
/// endfor
/// ```
///
/// Here is another small pseudo code fragment that shows how to use
/// `lsb_delta` and `rsb_delta` to improve integer positioning of glyphs:
///
/// ```
/// FT_GlyphSlot  slot           = face->glyph;
/// FT_Pos        origin_x       = 0;
/// FT_Pos        prev_rsb_delta = 0;
///
///
/// for all glyphs do
/// <compute kern between current and previous glyph
/// and add it to `origin_x'>
///
/// <load glyph with `FT_Load_Glyph'>
///
/// if ( prev_rsb_delta - slot->lsb_delta >  32 )
/// origin_x -= 64;
/// else if ( prev_rsb_delta - slot->lsb_delta < -31 )
/// origin_x += 64;
///
/// prev_rsb_delta = slot->rsb_delta;
///
/// <save glyph image, or render glyph, or ...>
///
/// origin_x += slot->advance.x;
/// endfor
/// ```
///
/// If you use strong auto-hinting, you **must** apply these delta values!
/// Otherwise you will experience far too large inter-glyph spacing at
/// small rendering sizes in most cases.  Note that it doesn't harm to use
/// the above code for other hinting modes also, since the delta values
/// are zero then.
final class FT_GlyphSlotRec_ extends ffi.Struct {
  external FT_Library library$;

  external FT_Face face;

  external FT_GlyphSlot next;

  @FT_UInt()
  external int glyph_index;

  external FT_Generic_ generic;

  external FT_Glyph_Metrics_ metrics;

  @FT_Fixed()
  external int linearHoriAdvance;

  @FT_Fixed()
  external int linearVertAdvance;

  external FT_Vector_ advance;

  @ffi.UnsignedInt()
  external int formatAsInt;

  FT_Glyph_Format_ get format => FT_Glyph_Format_.fromValue(formatAsInt);

  external FT_Bitmap_ bitmap;

  @FT_Int()
  external int bitmap_left;

  @FT_Int()
  external int bitmap_top;

  external FT_Outline_ outline;

  @FT_UInt()
  external int num_subglyphs;

  external ffi.Pointer<FT_SubGlyphRec_> subglyphs;

  external ffi.Pointer<ffi.Void> control_data;

  @ffi.Long()
  external int control_len;

  @FT_Pos()
  external int lsb_delta;

  @FT_Pos()
  external int rsb_delta;

  external ffi.Pointer<ffi.Void> other;

  external ffi.Pointer<FT_Slot_InternalRec_> internal;
}

/// @type:
/// FT_GlyphSlot
///
/// @description:
/// A handle to a given 'glyph slot'.  A slot is a container that can hold
/// any of the glyphs contained in its parent face.
///
/// In other words, each time you call @FT_Load_Glyph or @FT_Load_Char,
/// the slot's content is erased by the new glyph data, i.e., the glyph's
/// metrics, its image (bitmap or outline), and other control information.
///
/// @also:
/// See @FT_GlyphSlotRec for the publicly accessible glyph fields.
typedef FT_GlyphSlot$1 = ffi.Pointer<FT_GlyphSlotRec_>;

/// @struct:
/// FT_Size_Metrics
///
/// @description:
/// The size metrics structure gives the metrics of a size object.
///
/// @fields:
/// x_ppem ::
/// The width of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal width'.
///
/// y_ppem ::
/// The height of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal height'.
///
/// x_scale ::
/// A 16.16 fractional scaling value to convert horizontal metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// y_scale ::
/// A 16.16 fractional scaling value to convert vertical metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// ascender ::
/// The ascender in 26.6 fractional pixels, rounded up to an integer
/// value.  See @FT_FaceRec for the details.
///
/// descender ::
/// The descender in 26.6 fractional pixels, rounded down to an integer
/// value.  See @FT_FaceRec for the details.
///
/// height ::
/// The height in 26.6 fractional pixels, rounded to an integer value.
/// See @FT_FaceRec for the details.
///
/// max_advance ::
/// The maximum advance width in 26.6 fractional pixels, rounded to an
/// integer value.  See @FT_FaceRec for the details.
///
/// @note:
/// The scaling values, if relevant, are determined first during a size
/// changing operation.  The remaining fields are then set by the driver.
/// For scalable formats, they are usually set to scaled values of the
/// corresponding fields in @FT_FaceRec.  Some values like ascender or
/// descender are rounded for historical reasons; more precise values (for
/// outline fonts) can be derived by scaling the corresponding @FT_FaceRec
/// values manually, with code similar to the following.
///
/// ```
/// scaled_ascender = FT_MulFix( face->ascender,
/// size_metrics->y_scale );
/// ```
///
/// Note that due to glyph hinting and the selected rendering mode these
/// values are usually not exact; consequently, they must be treated as
/// unreliable with an error margin of at least one pixel!
///
/// Indeed, the only way to get the exact metrics is to render _all_
/// glyphs.  As this would be a definite performance hit, it is up to
/// client applications to perform such computations.
///
/// The `FT_Size_Metrics` structure is valid for bitmap fonts also.
///
///
/// **TrueType fonts with native bytecode hinting**
///
/// All applications that handle TrueType fonts with native hinting must
/// be aware that TTFs expect different rounding of vertical font
/// dimensions.  The application has to cater for this, especially if it
/// wants to rely on a TTF's vertical data (for example, to properly align
/// box characters vertically).
///
/// Only the application knows _in advance_ that it is going to use native
/// hinting for TTFs!  FreeType, on the other hand, selects the hinting
/// mode not at the time of creating an @FT_Size object but much later,
/// namely while calling @FT_Load_Glyph.
///
/// Here is some pseudo code that illustrates a possible solution.
///
/// ```
/// font_format = FT_Get_Font_Format( face );
///
/// if ( !strcmp( font_format, "TrueType" ) &&
/// do_native_bytecode_hinting         )
/// {
/// ascender  = ROUND( FT_MulFix( face->ascender,
/// size_metrics->y_scale ) );
/// descender = ROUND( FT_MulFix( face->descender,
/// size_metrics->y_scale ) );
/// }
/// else
/// {
/// ascender  = size_metrics->ascender;
/// descender = size_metrics->descender;
/// }
///
/// height      = size_metrics->height;
/// max_advance = size_metrics->max_advance;
/// ```
final class FT_Size_Metrics_ extends ffi.Struct {
  @FT_UShort()
  external int x_ppem;

  @FT_UShort()
  external int y_ppem;

  @FT_Fixed()
  external int x_scale;

  @FT_Fixed()
  external int y_scale;

  @FT_Pos()
  external int ascender;

  @FT_Pos()
  external int descender;

  @FT_Pos()
  external int height;

  @FT_Pos()
  external int max_advance;
}

final class FT_Size_InternalRec_ extends ffi.Opaque {}

/// @struct:
/// FT_SizeRec
///
/// @description:
/// FreeType root size class structure.  A size object models a face
/// object at a given size.
///
/// @fields:
/// face ::
/// Handle to the parent face object.
///
/// generic ::
/// A typeless pointer, unused by the FreeType library or any of its
/// drivers.  It can be used by client applications to link their own
/// data to each size object.
///
/// metrics ::
/// Metrics for this size object.  This field is read-only.
final class FT_SizeRec_ extends ffi.Struct {
  external FT_Face face;

  external FT_Generic_ generic;

  external FT_Size_Metrics_ metrics;

  external ffi.Pointer<FT_Size_InternalRec_> internal;
}

/// @type:
/// FT_Size
///
/// @description:
/// A handle to an object that models a face scaled to a given character
/// size.
///
/// @note:
/// An @FT_Face has one _active_ `FT_Size` object that is used by
/// functions like @FT_Load_Glyph to determine the scaling transformation
/// that in turn is used to load and hint glyphs and metrics.
///
/// A newly created `FT_Size` object contains only meaningless zero values.
/// You must use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes, @FT_Request_Size
/// or even @FT_Select_Size to change the content (i.e., the scaling
/// values) of the active `FT_Size`.  Otherwise, the scaling and hinting
/// will not be performed.
///
/// You can use @FT_New_Size to create additional size objects for a given
/// @FT_Face, but they won't be used by other functions until you activate
/// it through @FT_Activate_Size.  Only one size can be activated at any
/// given time per face.
///
/// @also:
/// See @FT_SizeRec for the publicly accessible fields of a given size
/// object.
typedef FT_Size = ffi.Pointer<FT_SizeRec_>;

final class FT_Face_InternalRec_ extends ffi.Opaque {}

final class FT_FaceRec_ extends ffi.Struct {
  @FT_Long()
  external int num_faces;

  @FT_Long()
  external int face_index;

  @FT_Long()
  external int face_flags;

  @FT_Long()
  external int style_flags;

  @FT_Long()
  external int num_glyphs;

  external ffi.Pointer<ffi.Char> family_name;

  external ffi.Pointer<ffi.Char> style_name;

  @FT_Int()
  external int num_fixed_sizes;

  external ffi.Pointer<FT_Bitmap_Size_> available_sizes;

  @FT_Int()
  external int num_charmaps;

  external ffi.Pointer<FT_CharMap> charmaps;

  external FT_Generic_ generic;

  external FT_BBox_ bbox;

  @FT_UShort()
  external int units_per_EM;

  @FT_Short()
  external int ascender;

  @FT_Short()
  external int descender;

  @FT_Short()
  external int height;

  @FT_Short()
  external int max_advance_width;

  @FT_Short()
  external int max_advance_height;

  @FT_Short()
  external int underline_position;

  @FT_Short()
  external int underline_thickness;

  external FT_GlyphSlot$1 glyph;

  external FT_Size size;

  external FT_CharMap charmap;

  external ffi.Pointer<FT_DriverRec_> driver;

  external ffi.Pointer<FT_MemoryRec_> memory;

  external ffi.Pointer<FT_StreamRec_> stream;

  external FT_ListRec_ sizes_list;

  external FT_Generic_ autohint;

  external ffi.Pointer<ffi.Void> extensions;

  external ffi.Pointer<FT_Face_InternalRec_> internal;
}

/// @enum:
/// FT_Size_Request_Type
///
/// @description:
/// An enumeration type that lists the supported size request types, i.e.,
/// what input size (in font units) maps to the requested output size (in
/// pixels, as computed from the arguments of @FT_Size_Request).
///
/// @values:
/// FT_SIZE_REQUEST_TYPE_NOMINAL ::
/// The nominal size.  The `units_per_EM` field of @FT_FaceRec is used
/// to determine both scaling values.
///
/// This is the standard scaling found in most applications.  In
/// particular, use this size request type for TrueType fonts if they
/// provide optical scaling or something similar.  Note, however, that
/// `units_per_EM` is a rather abstract value which bears no relation to
/// the actual size of the glyphs in a font.
///
/// FT_SIZE_REQUEST_TYPE_REAL_DIM ::
/// The real dimension.  The sum of the `ascender` and (minus of) the
/// `descender` fields of @FT_FaceRec is used to determine both scaling
/// values.
///
/// FT_SIZE_REQUEST_TYPE_BBOX ::
/// The font bounding box.  The width and height of the `bbox` field of
/// @FT_FaceRec are used to determine the horizontal and vertical
/// scaling value, respectively.
///
/// FT_SIZE_REQUEST_TYPE_CELL ::
/// The `max_advance_width` field of @FT_FaceRec is used to determine
/// the horizontal scaling value; the vertical scaling value is
/// determined the same way as @FT_SIZE_REQUEST_TYPE_REAL_DIM does.
/// Finally, both scaling values are set to the smaller one.  This type
/// is useful if you want to specify the font size for, say, a window of
/// a given dimension and 80x24 cells.
///
/// FT_SIZE_REQUEST_TYPE_SCALES ::
/// Specify the scaling values directly.
///
/// @note:
/// The above descriptions only apply to scalable formats.  For bitmap
/// formats, the behaviour is up to the driver.
///
/// See the note section of @FT_Size_Metrics if you wonder how size
/// requesting relates to scaling values.
enum FT_Size_Request_Type_ {
  FT_SIZE_REQUEST_TYPE_NOMINAL(0),
  FT_SIZE_REQUEST_TYPE_REAL_DIM(1),
  FT_SIZE_REQUEST_TYPE_BBOX(2),
  FT_SIZE_REQUEST_TYPE_CELL(3),
  FT_SIZE_REQUEST_TYPE_SCALES(4),
  FT_SIZE_REQUEST_TYPE_MAX(5);

  final int value;
  const FT_Size_Request_Type_(this.value);

  static FT_Size_Request_Type_ fromValue(int value) => switch (value) {
        0 => FT_SIZE_REQUEST_TYPE_NOMINAL,
        1 => FT_SIZE_REQUEST_TYPE_REAL_DIM,
        2 => FT_SIZE_REQUEST_TYPE_BBOX,
        3 => FT_SIZE_REQUEST_TYPE_CELL,
        4 => FT_SIZE_REQUEST_TYPE_SCALES,
        5 => FT_SIZE_REQUEST_TYPE_MAX,
        _ => throw ArgumentError(
            'Unknown value for FT_Size_Request_Type_: $value'),
      };
}

/// @struct:
/// FT_Size_RequestRec
///
/// @description:
/// A structure to model a size request.
///
/// @fields:
/// type ::
/// See @FT_Size_Request_Type.
///
/// width ::
/// The desired width, given as a 26.6 fractional point value (with 72pt
/// = 1in).
///
/// height ::
/// The desired height, given as a 26.6 fractional point value (with
/// 72pt = 1in).
///
/// horiResolution ::
/// The horizontal resolution (dpi, i.e., pixels per inch).  If set to
/// zero, `width` is treated as a 26.6 fractional **pixel** value, which
/// gets internally rounded to an integer.
///
/// vertResolution ::
/// The vertical resolution (dpi, i.e., pixels per inch).  If set to
/// zero, `height` is treated as a 26.6 fractional **pixel** value,
/// which gets internally rounded to an integer.
///
/// @note:
/// If `width` is zero, the horizontal scaling value is set equal to the
/// vertical scaling value, and vice versa.
///
/// If `type` is `FT_SIZE_REQUEST_TYPE_SCALES`, `width` and `height` are
/// interpreted directly as 16.16 fractional scaling values, without any
/// further modification, and both `horiResolution` and `vertResolution`
/// are ignored.
final class FT_Size_RequestRec_ extends ffi.Struct {
  @ffi.UnsignedInt()
  external int typeAsInt;

  FT_Size_Request_Type_ get type => FT_Size_Request_Type_.fromValue(typeAsInt);

  @FT_Long()
  external int width;

  @FT_Long()
  external int height;

  @FT_UInt()
  external int horiResolution;

  @FT_UInt()
  external int vertResolution;
}

/// @enum:
/// FT_Render_Mode
///
/// @description:
/// Render modes supported by FreeType~2.  Each mode corresponds to a
/// specific type of scanline conversion performed on the outline.
///
/// For bitmap fonts and embedded bitmaps the `bitmap->pixel_mode` field
/// in the @FT_GlyphSlotRec structure gives the format of the returned
/// bitmap.
///
/// All modes except @FT_RENDER_MODE_MONO use 256 levels of opacity,
/// indicating pixel coverage.  Use linear alpha blending and gamma
/// correction to correctly render non-monochrome glyph bitmaps onto a
/// surface; see @FT_Render_Glyph.
///
/// The @FT_RENDER_MODE_SDF is a special render mode that uses up to 256
/// distance values, indicating the signed distance from the grid position
/// to the nearest outline.
///
/// @values:
/// FT_RENDER_MODE_NORMAL ::
/// Default render mode; it corresponds to 8-bit anti-aliased bitmaps.
///
/// FT_RENDER_MODE_LIGHT ::
/// This is equivalent to @FT_RENDER_MODE_NORMAL.  It is only defined as
/// a separate value because render modes are also used indirectly to
/// define hinting algorithm selectors.  See @FT_LOAD_TARGET_XXX for
/// details.
///
/// FT_RENDER_MODE_MONO ::
/// This mode corresponds to 1-bit bitmaps (with 2~levels of opacity).
///
/// FT_RENDER_MODE_LCD ::
/// This mode corresponds to horizontal RGB and BGR subpixel displays
/// like LCD screens.  It produces 8-bit bitmaps that are 3~times the
/// width of the original glyph outline in pixels, and which use the
/// @FT_PIXEL_MODE_LCD mode.
///
/// FT_RENDER_MODE_LCD_V ::
/// This mode corresponds to vertical RGB and BGR subpixel displays
/// (like PDA screens, rotated LCD displays, etc.).  It produces 8-bit
/// bitmaps that are 3~times the height of the original glyph outline in
/// pixels and use the @FT_PIXEL_MODE_LCD_V mode.
///
/// FT_RENDER_MODE_SDF ::
/// The positive (unsigned) 8-bit bitmap values can be converted to the
/// single-channel signed distance field (SDF) by subtracting 128, with
/// the positive and negative results corresponding to the inside and
/// the outside of a glyph contour, respectively.  The distance units are
/// arbitrarily determined by an adjustable @spread property.
///
/// @note:
/// The selected render mode only affects scalable vector glyphs of a font.
/// Embedded bitmaps often have a different pixel mode like
/// @FT_PIXEL_MODE_MONO.  You can use @FT_Bitmap_Convert to transform them
/// into 8-bit pixmaps.
enum FT_Render_Mode_ {
  FT_RENDER_MODE_NORMAL(0),
  FT_RENDER_MODE_LIGHT(1),
  FT_RENDER_MODE_MONO(2),
  FT_RENDER_MODE_LCD(3),
  FT_RENDER_MODE_LCD_V(4),
  FT_RENDER_MODE_SDF(5),
  FT_RENDER_MODE_MAX(6);

  final int value;
  const FT_Render_Mode_(this.value);

  static FT_Render_Mode_ fromValue(int value) => switch (value) {
        0 => FT_RENDER_MODE_NORMAL,
        1 => FT_RENDER_MODE_LIGHT,
        2 => FT_RENDER_MODE_MONO,
        3 => FT_RENDER_MODE_LCD,
        4 => FT_RENDER_MODE_LCD_V,
        5 => FT_RENDER_MODE_SDF,
        6 => FT_RENDER_MODE_MAX,
        _ => throw ArgumentError('Unknown value for FT_Render_Mode_: $value'),
      };
}

/// @enum:
/// FT_Kerning_Mode
///
/// @description:
/// An enumeration to specify the format of kerning values returned by
/// @FT_Get_Kerning.
///
/// @values:
/// FT_KERNING_DEFAULT ::
/// Return grid-fitted kerning distances in 26.6 fractional pixels.
///
/// FT_KERNING_UNFITTED ::
/// Return un-grid-fitted kerning distances in 26.6 fractional pixels.
///
/// FT_KERNING_UNSCALED ::
/// Return the kerning vector in original font units.
///
/// @note:
/// `FT_KERNING_DEFAULT` returns full pixel values; it also makes FreeType
/// heuristically scale down kerning distances at small ppem values so
/// that they don't become too big.
///
/// Both `FT_KERNING_DEFAULT` and `FT_KERNING_UNFITTED` use the current
/// horizontal scaling factor (as set e.g. with @FT_Set_Char_Size) to
/// convert font units to pixels.
enum FT_Kerning_Mode_ {
  FT_KERNING_DEFAULT(0),
  FT_KERNING_UNFITTED(1),
  FT_KERNING_UNSCALED(2);

  final int value;
  const FT_Kerning_Mode_(this.value);

  static FT_Kerning_Mode_ fromValue(int value) => switch (value) {
        0 => FT_KERNING_DEFAULT,
        1 => FT_KERNING_UNFITTED,
        2 => FT_KERNING_UNSCALED,
        _ => throw ArgumentError('Unknown value for FT_Kerning_Mode_: $value'),
      };
}

const int FT_FACE_FLAG_SCALABLE = 1;

const int FT_FACE_FLAG_FIXED_SIZES = 2;

const int FT_FACE_FLAG_FIXED_WIDTH = 4;

const int FT_FACE_FLAG_SFNT = 8;

const int FT_FACE_FLAG_HORIZONTAL = 16;

const int FT_FACE_FLAG_VERTICAL = 32;

const int FT_FACE_FLAG_KERNING = 64;

const int FT_FACE_FLAG_FAST_GLYPHS = 128;

const int FT_FACE_FLAG_MULTIPLE_MASTERS = 256;

const int FT_FACE_FLAG_GLYPH_NAMES = 512;

const int FT_FACE_FLAG_EXTERNAL_STREAM = 1024;

const int FT_FACE_FLAG_HINTER = 2048;

const int FT_FACE_FLAG_CID_KEYED = 4096;

const int FT_FACE_FLAG_TRICKY = 8192;

const int FT_FACE_FLAG_COLOR = 16384;

const int FT_FACE_FLAG_VARIATION = 32768;

const int FT_FACE_FLAG_SVG = 65536;

const int FT_FACE_FLAG_SBIX = 131072;

const int FT_FACE_FLAG_SBIX_OVERLAY = 262144;

const int FT_LOAD_DEFAULT = 0;

const int FT_LOAD_NO_SCALE = 1;

const int FT_LOAD_NO_HINTING = 2;

const int FT_LOAD_RENDER = 4;

const int FT_LOAD_NO_BITMAP = 8;

const int FT_LOAD_VERTICAL_LAYOUT = 16;

const int FT_LOAD_FORCE_AUTOHINT = 32;

const int FT_LOAD_CROP_BITMAP = 64;

const int FT_LOAD_PEDANTIC = 128;

const int FT_LOAD_NO_RECURSE = 1024;

const int FT_LOAD_IGNORE_TRANSFORM = 2048;

const int FT_LOAD_MONOCHROME = 4096;

const int FT_LOAD_LINEAR_DESIGN = 8192;

const int FT_LOAD_NO_AUTOHINT = 32768;

const int FT_LOAD_COLOR = 1048576;

const int FT_LOAD_COMPUTE_METRICS = 2097152;

const int FT_LOAD_BITMAP_METRICS_ONLY = 4194304;

const int FREETYPE_MAJOR = 2;

const int FREETYPE_MINOR = 13;

const int FREETYPE_PATCH = 3;
